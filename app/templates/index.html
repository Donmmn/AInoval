<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>主界面 - 小说编辑器</title>
    <link rel="stylesheet" href="/static/style.css">
    <!-- 引入 Font Awesome 图标库 (示例) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <style>
        .editor-container {
            margin: 0;
            width: 100%;
            padding: 0; /* 确保无 padding */
            display: flex;
            flex-direction: column;
            position: relative;
            flex: 1;
            overflow: hidden;
        }
        .novel-editor-area {
            flex: 1; 
            display: flex; 
            flex-direction: column;
            position: relative; 
            overflow: hidden; 
            padding: 0; /* 确保无 padding */
        }
        .novel-editor { /* #novel-content */
            width: 100%;
            min-height: 150px;
            resize: vertical;
            border: none; 
            font-size: 18px;
            /* padding: 20px 0 100px 20px; */ /* T R B L - Original offset for prompt bar */
            /* New padding: Add significant bottom padding (e.g., 50vh) */
            padding: 20px 0 calc(50vh + 120px) 20px; /* T=20, R=0, B=50% VH + PromptBarOffset, L=20 */
            outline: none;
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: #fafbfc; 
            border-radius: 0; 
            box-sizing: border-box;
            flex: 1;
            overflow-y: auto;
        }
        .prompt-bar {
            position: absolute;
            bottom: 15px; 
            left: 5%; 
            right: 5%;
            width: 90%; 
            z-index: 10; 
            box-sizing: border-box; 
            margin: 0 auto; 
            background: #ffffff; 
            border-radius: 8px; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.15); 
            padding: 15px 20px; /* Restore original padding */
            display: flex; /* Use flex for the row inside */
        }
        .prompt-row {
            display: flex;
            align-items: stretch; 
            gap: 10px; /* Gap between textarea and buttons */
            width: 100%;
        }
        textarea.prompt-input {
            flex: 1; /* Take up most horizontal space */
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 15px;
            padding: 8px 10px;
            overflow-y: auto; 
            font-family: inherit;
            line-height: 1.4;
            min-height: 70px; 
        }
        .prompt-actions {
            display: flex; 
            flex-direction: column;
            gap: 4px;
            align-items: stretch; /* Make buttons fill width */
            flex-shrink: 0; /* Prevent shrinking */
            width: 80px; 
        }
        .prompt-actions button {
            padding: 6px 18px;
            font-size: 15px;
            width: 100%; /* Ensure button takes width from container */
            text-align: center;
            box-sizing: border-box;
            border: 1px solid #ccc; /* Add a default border */
            background-color: #f0f0f0; /* Default background */
            color: #333; /* Default text color */
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s; /* Add transitions */
        }
        .prompt-actions button:hover {
             background-color: #e0e0e0; /* Hover background */
        }
        .prompt-actions button:disabled {
            background-color: #ddd; /* Disabled background */
            color: #999; /* Disabled text color */
            cursor: not-allowed;
        }

        /* 新增：保存成功状态 */
        .prompt-actions button.save-success {
            background-color: #d1e7dd; /* Light green background (Bootstrap success) */
            border-color: #a3cfbb; /* Green border */
            color: #0f5132; /* Dark green text */
        }

        body {
            background: #f7f7f7;
            overflow-x: hidden; /* 防止横向滚动条 */
        }
        .main-flex {
            display: flex;
            width: 100vw;
            min-height: calc(100vh - 60px); /* 减去顶部栏高度 */
        }

        /* 左侧边栏 */
        .left-sidebar {
            width: 15vw;
            min-width: 200px; /* 最小宽度 */
            max-width: 300px; /* 最大宽度 */
            background: #e9eef2;
            border-right: 1px solid #d3d9df;
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            overflow-y: auto; /* 内容多时可滚动 */
        }
        .sidebar-actions {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            gap: 10px;
        }
        .sidebar-btn {
            flex: 1; /* 平分空间 */
            background: #888;
            color: #fff;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
            text-align: center;
        }
        .sidebar-btn.delete-btn {
            background: #c77; /* 删除按钮用不同颜色 */
        }
        .sidebar-btn:hover {
            background: #222;
        }
        .sidebar-btn.delete-btn:hover {
            background: #a55;
        }

        /* 文件列表 */
        .file-list {
            list-style: none;
            padding: 0;
            margin: 0;
            flex-grow: 1; /* 占据剩余空间 */
        }
        .file-item {
            padding: 6px 2px 6px 5px; /* 微调内边距 T R B L */
            margin-bottom: 3px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 15px;
            user-select: none;
            position: relative;
            background-color: transparent; 
        }
        .file-item:hover {
            background-color: #dce4eb;
        }
        .file-item i { /* 图标样式 */
            margin-right: 8px;
            color: #555;
            width: 16px; /* 固定图标宽度 */
            text-align: center;
            vertical-align: middle;
        }
        .file-item .folder-toggle { /* 文件夹折叠图标 */
             transition: transform 0.2s ease-in-out;
             vertical-align: middle;
        }
        .file-item.collapsed .folder-toggle {
             transform: rotate(-90deg);
        }
        .file-item .item-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: inline-block;
            vertical-align: middle;
        }
        .file-item input.rename-input { /* 重命名输入框 */
            border: 1px solid #999;
            padding: 2px 4px;
            font-size: 15px;
            outline: none;
            width: calc(100% - 50px); /* 示例 */
            display: inline-block;
            vertical-align: middle;
        }
        .file-item ul { /* 子列表 */
            list-style: none;
            padding-left: 25px; /* 子项缩进 - 保持 */
            margin-top: 5px;
            display: block;
            width: 100%;
            box-sizing: border-box;
        }
        .file-item.collapsed ul {
            display: none;
        }

        /* 中间编辑区容器 */
        .editor-outer {
            flex: 1;
            display: flex;
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
            height: calc(100vh - 60px);
            max-height: calc(100vh - 60px);
        }
        textarea.prompt-input {
            flex: 1;
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 15px;
            padding: 8px 10px;
            overflow-y: auto; 
            font-family: inherit;
            line-height: 1.4;
            align-self: stretch; 
            resize: none; 
        }
        .word-count-input {
             width: 80px;
             font-size: 15px;
             padding: 8px 10px;
        }
        .word-count-label {
             margin-right: 4px;
        }
        .prompt-actions {
             display: flex;
             flex-direction: column;
             gap: 4px;
             align-items: flex-start;
        }
         .prompt-actions button {
            padding: 6px 18px;
            font-size: 15px;
        }

        /* 右侧边栏 */
        .right-sidebar {
            width: 20vw; /* 比左侧宽一点 */
            min-width: 250px;
            max-width: 350px;
            background: #f0f3f6;
            border-left: 1px solid #d3d9df;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
        }
        .right-sidebar h3 {
            margin-top: 0;
            color: #444;
            border-bottom: 1px solid #ccc;
            padding-bottom: 10px;
        }
        #setting-content ul {
             list-style: disc;
             padding-left: 20px;
        }
         #setting-content li {
             margin-bottom: 8px;
             background: #fff;
             padding: 5px 8px;
             border-radius: 4px;
             box-shadow: 0 1px 2px rgba(0,0,0,0.05);
         }

        /* 简单的右键菜单样式 */
        .context-menu {
            position: absolute;
            background: #fff;
            border: 1px solid #ccc;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 5px 0;
            border-radius: 4px;
            z-index: 1000;
            display: none; /* 默认隐藏 */
        }
        .context-menu div {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
        }
        .context-menu div:hover {
            background: #eee;
        }

         /* 创建菜单 */
         #create-menu {
             /* 样式与 context-menu 类似 */
             position: absolute;
             background: #fff;
             border: 1px solid #ccc;
             box-shadow: 0 2px 5px rgba(0,0,0,0.1);
             padding: 5px 0;
             border-radius: 4px;
             z-index: 1000;
             display: none;
         }
         #create-menu div {
             padding: 8px 15px;
             cursor: pointer;
             font-size: 14px;
         }
         #create-menu div:hover {
             background: #eee;
         }

        /* 拖放视觉反馈样式 */
        .file-item.drag-over-folder { /* 拖到文件夹上 */
            background-color: #cce5ff !important; /* 淡蓝色背景 */
            outline: 1px dashed #007bff;
        }

        .file-item.drag-over-insert-before,
        .file-item.drag-over-insert-after {
             position: relative; /* 确保伪元素相对于它定位 */
        }

        .file-item.drag-over-insert-before::before,
        .file-item.drag-over-insert-after::after { /* 插入指示线 */
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            height: 2px;
            background-color: #007bff; /* 蓝色指示线 */
            z-index: 1;
        }
        .file-item.drag-over-insert-before::before {
            top: -1px; /* 显示在元素上方 */
        }
        .file-item.drag-over-insert-after::after {
            bottom: -1px; /* 显示在元素下方 */
        }

        #delete-btn.drag-over-delete { /* 拖到删除区域上 */
            background-color: #f8d7da !important; /* 淡红色背景 */
            border: 1px dashed #dc3545;
            outline: none; /* 覆盖默认 outline */
        }

        .file-item.dragging { /* 被拖动的元素本身 */
            outline: 2px dashed #ff8c00; 
            background-color: #fff8dc; /* 给一个轻微的背景色 */
        }

        .file-item.drag-over-associate { /* 拖设定书到书上 */
            background-color: #d1e7dd !important; /* 淡绿色背景 */
            outline: 1px dashed #198754;
        }

        /* Right Sidebar Setting Editor Styles */
        #setting-content {
            position: relative; /* Needed for absolute positioning of buttons */
        }
        .setting-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
        }
        .setting-item {
            display: flex;
            align-items: flex-start; /* Align items to the top */
            gap: 8px;
            margin-bottom: 10px;
            padding: 8px 8px 8px 4px; /* Reduce left padding (T R B L) */
            background-color: #fff;
            border-radius: 4px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .setting-item-controls {
            display: flex;
            align-items: center; /* Center checkbox and delete button vertically */
            gap: 5px;
            /* Give controls a fixed width if needed, or let them shrink */
        }
        .setting-item input[type=\"checkbox\"] {
            /* Style checkbox */
            width: 16px;
            height: 16px;
            cursor: pointer;
            margin-top: 4px; /* Adjust vertical alignment */
        }
        .setting-item textarea {
            flex: 1; /* Take up remaining space */
            min-height: 40px; /* Start height */
            height: auto; /* Allow auto-height based on content */
            resize: vertical; /* Allow vertical resize */
            max-height: 120px; /* Limit max height */
            overflow-y: auto;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 6px 8px;
            font-size: 14px;
            line-height: 1.4;
            box-sizing: border-box;
        }
        .setting-item .delete-setting-btn {
            background: #f8d7da;
            color: #842029;
            border: 1px solid #f5c2c7;
            border-radius: 50%; /* Make it round */
            width: 22px;
            height: 22px;
            line-height: 20px; /* Adjust for vertical centering */
            text-align: center;
            cursor: pointer;
            font-weight: bold;
            padding: 0;
            margin-top: 2px; /* Adjust vertical alignment */
            flex-shrink: 0; /* Prevent shrinking */
        }
        .setting-item .delete-setting-btn:hover {
            background: #e5a4aa;
        }

        .setting-header {
            display: flex;
            justify-content: space-between; /* Title left, buttons right */
            align-items: center;
            margin-bottom: 10px; /* Space below header */
            border-bottom: 1px solid #ccc;
            padding-bottom: 10px;
        }
        .setting-header h3 {
            margin: 0; /* Remove default margin */
            color: #444;
            flex-grow: 1; /* Allow title to take up space */
            border-bottom: none; /* Remove duplicate border */
            padding-bottom: 0;
        }
        .setting-actions {
            /* margin-top: 15px; */ /* Remove top margin as it's now in header */
            display: flex;
            gap: 8px; /* Space between buttons */
            /* justify-content: flex-end; */ /* No longer needed */
            flex-shrink: 0; /* Prevent buttons from shrinking */
        }
        .setting-actions button {
            padding: 5px 12px; /* Adjust padding for smaller buttons */
            border-radius: 5px; /* Rounded rectangle */
            cursor: pointer;
            font-size: 13px; /* Slightly smaller font */
            border: 1px solid transparent; /* Base border */
            line-height: normal; /* Reset line-height */
            height: auto; /* Reset height */
            width: auto; /* Reset width */
            text-align: center;
        }
        #add-setting-btn {
             background-color: #cfe2ff;
             border-color: #b6d4fe;
             color: #084298;
             font-size: 16px; /* Keep '+' slightly larger */
             /* Remove circle/fixed size styles */
             /* width: 30px; */
             /* height: 30px; */
             /* padding: 0; */
             /* border-radius: 50%; */
             /* align-self: flex-start; */
             /* margin-top: 5px; */
        }
        #save-settings-btn {
             background-color: #d1e7dd;
             border-color: #a3cfbb;
             color: #0f5132;
        }
        
        .setting-item {
            display: flex;
            align-items: flex-start; 
            gap: 8px;
            margin-bottom: 10px;
            padding: 8px 8px 8px 4px; /* Reduce left padding (T R B L) */
            background-color: #fff;
            border-radius: 4px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            width: 100%; 
            box-sizing: border-box;
        }
        /* ... other setting item styles ... */

        #right-sidebar-title {
            display: flex;
            justify-content: space-between; /* Pushes title left, badge right */
            align-items: center; /* Vertically aligns items */
            /* Ensure h3 takes full width if needed, or adjust parent */
            width: 100%;
            box-sizing: border-box; /* Include padding/border in width */
        }

        .book-title-text {
            /* Allows the title to take space but not push the badge too far */
            flex-grow: 1;
             /* Prevent title from becoming too small if badge is wide */
            min-width: 0;
            /* Add ellipsis if title is very long */
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-right: 10px; /* Space between title and badge */
             /* Match existing h3 font size/style if needed */
             font-size: inherit;
             font-weight: inherit;
             color: inherit;
             margin-bottom: 0; /* Override default h3 margin if any */
             padding-bottom: 0; /* Override default h3 padding if any */
             border-bottom: none; /* Override default h3 border if any */

        }

        .word-count-badge {
            background-color: #e9ecef; /* Light grey background */
            color: #495057; /* Darker grey text */
            padding: 3px 8px; /* Small padding */
            border-radius: 10px; /* Rounded corners */
            font-size: 0.8em; /* Smaller font size */
            font-weight: normal; /* Normal weight */
            white-space: nowrap; /* Prevent wrapping */
            flex-shrink: 0; /* Prevent badge from shrinking */
            transition: background-color 0.3s, color 0.3s; /* Smooth transition */
        }

        .word-count-badge.limit-exceeded {
            background-color: #f8d7da; /* Light red background */
            color: #842029; /* Darker red text */
            font-weight: bold;
        }

        /* Ensure the h3 itself doesn't have conflicting styles */
         .right-sidebar h3 {
             /* Remove conflicting styles if they exist from previous steps */
             /* For example, reset borders/padding if they interfere with flex */
             /* border-bottom: 1px solid #ccc; */ /* Likely remove this */
             /* padding-bottom: 10px; */ /* Likely remove this */
             margin-bottom: 10px; /* Keep space below the title bar */
         }

         /* Adjust setting header if the main h3 border was removed */
         .setting-header {
             /* Maybe add border here if needed */
             /* border-bottom: 1px solid #ccc; */
             /* padding-bottom: 10px; */
         }

         /* --- 顶部栏样式调整 --- */
        .top-bar {
            /* ... (保留原有样式) ... */
            display: flex; /* 使用 Flexbox 布局 */
            justify-content: space-between; /* 两端对齐 */
            align-items: center; /* 垂直居中 */
            padding: 0 20px; /* 左右内边距 */
            gap: 15px; /* 按钮间距 */
        }

        .left-controls {
            display: flex;
            align-items: center;
            gap: 8px; /* 标签和开关间距 */
        }

        .auto-save-label {
            color: #eee; /* 标签颜色 */
            font-size: 14px;
            user-select: none; /* 防止文本被选中 */
        }

        /* 简单的切换开关样式 */
        .toggle-switch {
            appearance: none;
            -webkit-appearance: none;
            position: relative;
            width: 40px; /* 开关宽度 */
            height: 22px; /* 开关高度 */
            border-radius: 11px; /* 圆角 */
            background-color: #aaa; /* 关闭状态背景 */
            cursor: pointer;
            transition: background-color 0.3s;
            vertical-align: middle; /* 对齐标签 */
        }

        .toggle-switch::before {
            content: '';
            position: absolute;
            top: 2px; /* 圆点上边距 */
            left: 2px; /* 圆点左边距 */
            width: 18px; /* 圆点宽度 */
            height: 18px; /* 圆点高度 */
            border-radius: 50%; /* 圆形 */
            background-color: white; /* 圆点颜色 */
            transition: transform 0.3s;
        }

        .toggle-switch:checked {
            background-color: #4CAF50; /* 开启状态背景 (绿色) */
        }

        .toggle-switch:checked::before {
            transform: translateX(18px); /* 圆点移动距离 */
        }

        /* 调整右侧按钮间距 (如果需要) */
        .right-buttons {
            display: flex;
            gap: 15px; /* 按钮间距 */
        }

        /* --- 中间显示区域样式 (用于显示未关联书籍列表) --- */
        #central-display-area {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
            background-color: #f0f3f6; /* 给个背景色区分 */
        }
        #central-display-area h4 { /* 列表标题样式 */
            margin-top: 0;
            margin-bottom: 15px;
            color: #555;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        .unassociated-book-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .unassociated-book-item {
            padding: 10px 15px;
            margin-bottom: 8px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 15px;
        }
        .unassociated-book-item:hover {
            background-color: #e9eef2;
            border-color: #cdd7e0;
        }
        .unassociated-book-item i {
            color: #666;
            width: 16px; /* 与左侧列表图标对齐 */
            text-align: center;
        }

        /* 新增：点数余额样式 */
        .points-balance {
            color: #ffdd57; /* Light yellow color */
            font-size: 14px;
            margin-right: 10px; /* Space before AI service button */
            font-weight: bold;
        }
        .points-balance .fas { /* Icon style */
            margin-right: 4px;
            font-size: 13px;
        }

        /* 新增：提示词栏选项样式 */
        .prompt-bar {
            /* ... */
            padding: 10px 15px; /* 微调 padding */
        }
        .prompt-row {
            /* ... */
            align-items: flex-start; /* 改为顶部对齐 */
            gap: 15px; /* 增加间距 */
        }
        .prompt-options {
            display: flex;
            flex-direction: column; /* 垂直排列选项 */
            gap: 8px; /* 选项之间的间距 */
            flex-shrink: 0; /* 防止被压缩 */
            width: 180px; /* 给一个固定宽度 */
        }
        .prompt-options div {
            display: flex;
            align-items: center; /* 标签和输入框对齐 */
            gap: 5px; /* 标签和输入框间距 */
        }
        .prompt-options label {
            width: 40px; /* 固定标签宽度 */
            text-align: right;
            font-size: 14px;
            color: #333;
            flex-shrink: 0;
        }
        .prompt-options select,
        .prompt-options input[type="number"],
        .prompt-options input[type="text"] {
            flex-grow: 1; /* 输入框占据剩余空间 */
            padding: 6px 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            min-width: 0; /* 允许输入框缩小 */
        }

        textarea.prompt-input {
            /* ... */
            min-height: 80px; /* 可能需要调整高度 */
        }
        .prompt-actions {
             width: 70px; /* 微调按钮区宽度 */
        }

<<<<<<< 初步稳定版
=======
        /* --- Styles for AI Generated Content --- */
        .ai-generated {
            background-color: #e0f7ff; /* Light blue background */
            padding: 1px 2px; /* Minimal padding */
            border-radius: 3px;
            position: relative; /* Needed for absolute positioning of button */
            /* display: inline; Doesn't work well with block elements inside */
        }
        .delete-gen-btn {
            background: #ff4d4d;
            color: white;
            border: none;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            line-height: 15px; /* Adjust for centering X */
            text-align: center;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            padding: 0;
            margin-left: 5px; /* Space from text */
            vertical-align: middle; /* Align with text */
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .delete-gen-btn:hover {
            opacity: 1;
        }
        /* --- End AI Generated Styles --- */

        /* --- Styles for Generation Preview --- */
        #generation-preview-area {
            position: absolute; /* Position relative to .novel-editor-area */
            top: 0;
            left: 0;
            width: 100%;
            height: 100%; /* Cover the editor area */
            background-color: white; /* Cover the underlying editor */
            display: none; /* Hidden by default */
            flex-direction: column;
            padding: 10px; /* Add some padding */
            box-sizing: border-box;
            z-index: 5; /* Ensure it's above the normal editor but below prompt bar? Adjust as needed */
        }
        #generation-preview-area h4 {
             margin: 0 0 10px 0;
             color: #333;
             font-size: 16px;
             text-align: center;
             flex-shrink: 0; /* Prevent shrinking */
        }
        #generation-preview-area textarea {
            width: 100%;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 8px;
            font-size: 14px; /* Slightly smaller for preview? */
            font-family: inherit;
            box-sizing: border-box;
            margin-bottom: 8px; /* Space between textareas */
        }
        #preview-before, #preview-after {
             flex: 1; /* Distribute remaining space */
             min-height: 100px; /* Ensure minimum height */
             resize: vertical;
        }
        #preview-generated {
            background-color: #f0f0f0; /* Light gray background */
            min-height: 150px; /* Give generated text more space */
            flex-basis: 40%; /* Give it a larger base size */
            flex-grow: 2; /* Allow it to grow more than others */
            resize: vertical;
        }
         .generation-preview-actions {
             display: flex;
             justify-content: flex-end; /* Buttons on the right */
             gap: 10px;
             margin-top: 10px;
             flex-shrink: 0; /* Prevent shrinking */
         }
         .generation-preview-actions button {
            padding: 8px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            border: 1px solid #ccc;
         }
         #apply-generation-btn {
            background-color: #d1e7dd; /* Greenish */
            border-color: #a3cfbb;
            color: #0f5132;
         }
         #cancel-generation-btn {
             background-color: #f8d7da; /* Reddish */
             border-color: #f5c2c7;
             color: #842029;
         }
        /* --- End Preview Styles --- */
>>>>>>> local
    </style>
</head>
<body>
    <div class="top-bar">
        <div class="left-controls"> <!-- 新增容器 -->
            <label for="auto-save-toggle" class="auto-save-label">离开时自动保存: </label>
            {# 根据后端传递的值决定是否默认选中，并将值存入 data 属性 #}
            <input type="checkbox" id="auto-save-toggle"
                   class="toggle-switch"
                   data-initial-state="{{ user_auto_save_setting | tojson }}"
                   {% if user_auto_save_setting %}checked{% endif %}>
        </div>
        <div class="right-buttons">
            {% if current_user.is_authenticated and current_user.is_admin %}
            <a href="{{ url_for('user.manage') }}" class="top-btn">用户管理</a>
            {% endif %}
            {# 新增：显示点数余额 (仅对非管理员显示) #}
            {% if not current_user.is_admin %}
            <span class="points-balance" id="user-points-display">
                <i class="fas fa-coins"></i> {{ user_points }}
            </span>
            {% endif %}
            <a href="{{ url_for('ai_service.manage') }}" class="top-btn">AI服务管理</a>
            <a href="{{ url_for('main.logout') }}" class="top-btn">退出登录</a>
        </div>
    </div>

    <div class="main-flex">
        <!-- 左侧文件列表 -->
        <div class="left-sidebar">
            <div class="sidebar-actions">
                <button id="create-btn" class="sidebar-btn">创建</button>
                <button id="delete-btn" class="sidebar-btn delete-btn">删除区域</button>
            </div>
            <ul id="file-list" class="file-list">
                <!-- 文件项将由 JS 动态生成 -->
            </ul>
        </div>

        <!-- 中间编辑区 -->
        <div class="editor-outer">
            <div class="editor-container">
                <div class="novel-editor-area">
                    {# Central display for unrelated items #}
                    <div id="central-display-area" style="display: none;">
                        <!-- Content generated by JS -->
                    </div>
<<<<<<< 初步稳定版
                    {# 原有的编辑区 #}
=======

                    {# Main editor - Textarea #}
>>>>>>> local
                    <textarea id="novel-content" class="novel-editor" placeholder="在这里编辑你的小说内容..."></textarea>

                    {# Generation Preview Area - Hidden by default #}
                    <div id="generation-preview-area">
                        <h4>生成预览</h4>
                        <textarea id="preview-before" readonly placeholder="光标前内容..."></textarea>
                        <textarea id="preview-generated" placeholder="AI生成内容..."></textarea>
                        <textarea id="preview-after" readonly placeholder="光标后内容..."></textarea>
                        <div class="generation-preview-actions">
                            <button id="cancel-generation-btn">取消</button>
                            <button id="apply-generation-btn">应用</button>
                        </div>
                    </div>

                    {# Prompt Bar - Restore content #}
                    <div class="prompt-bar">
                         <div class="prompt-row">
                             <div class="prompt-options">
                                 <div>
                                     <label for="template-select">模板:</label>
                                     <select id="template-select" name="template_id">
                                         <option value="">-- 选择模板 --</option>
                                         <!-- 模板选项将由 JS 填充 -->
                                     </select>
                                 </div>
                                 <div>
                                     <label for="ai-service-select">服务:</label>
                                     <select id="ai-service-select" name="ai_service_config_id">
                                         <option value="">-- 使用默认 --</option>
                                         <!-- AI 服务选项将由 JS 填充 -->
                                     </select>
                                 </div>
                                 <div>
                                     <label for="word-count-input">字数:</label>
                                     <input type="number" id="word-count-input" value="500" min="10" max="4000" step="10">
                                 </div>
                                 <div>
                                     <label for="style-input">风格:</label>
                                     <input type="text" id="style-input" placeholder="例如：奇幻、科幻...">
                                 </div>
                             </div>
                             <textarea class="prompt-input" placeholder="输入AI提示词..." rows="3"></textarea>
                             <div class="prompt-actions">
                                 <button id="generate-btn" type="button">生成</button>
                                 <button id="retry-btn" type="button">重试</button>
                                 {# Removed Undo Button for now as it was tied to contenteditable #}
                                 {# <button id="undo-gen-btn" type="button" style="display: none; ...">撤销 [x]</button> #}
                                 <button id="save-btn" type="button">保存</button>
                             </div>
                         </div>
                    </div>
                </div> <!-- This closes novel-editor-area -->
            </div> <!-- This closes editor-container -->
        </div> <!-- This closes editor-outer -->

        <!-- 右侧设定书显示区 -->
        <div class="right-sidebar">
             <h3 id="right-sidebar-title">
                 <span class="book-title-text">设定详情</span>
                 <span class="word-count-badge" style="display: none;"></span> <!-- Initially hidden -->
             </h3>
            <div id="setting-content">
                <p>点击左侧设定书查看详情</p>
                <!-- 设定内容将由 JS 动态生成 -->
            </div>
        </div>
    </div>

    <!-- 右键菜单 -->
    <div id="context-menu" class="context-menu">
        <div data-action="rename">重命名</div>
        <div data-action="delete">删除</div>
    </div>

    <!-- 创建菜单 -->
     <div id="create-menu">
         <div data-type="folder">文件夹</div>
         <div data-type="book">书籍</div>
         <div data-type="setting">设定书</div>
     </div>


    <script>
<<<<<<< 初步稳定版
        // 移除本地示例数据
        // let fileData = [ ... ];

        const fileList = document.getElementById('file-list');
        const contextMenu = document.getElementById('context-menu');
        const createMenu = document.getElementById('create-menu');
        const createBtn = document.getElementById('create-btn');
        const deleteBtn = document.getElementById('delete-btn');
        const settingContent = document.getElementById('setting-content');
        const novelContent = document.getElementById('novel-content');
        const rightSidebarTitle = document.getElementById('right-sidebar-title');
        const bookTitleTextSpan = rightSidebarTitle.querySelector('.book-title-text'); // Get title span
        const wordCountBadgeSpan = rightSidebarTitle.querySelector('.word-count-badge'); // Get badge span
        const autoSaveToggle = document.getElementById('auto-save-toggle'); // 获取自动保存开关
        const centralDisplayArea = document.getElementById('central-display-area'); // 获取中央显示区域
        const promptBar = document.querySelector('.prompt-bar'); // 获取提示词栏
        const templateSelect = document.getElementById('template-select');
        const wordCountInput = document.getElementById('word-count-input');
        const styleInput = document.getElementById('style-input');
        const promptInput = document.querySelector('.prompt-input'); // 获取提示词输入框
        const generateBtn = document.getElementById('generate-btn');
        const aiServiceSelect = document.getElementById('ai-service-select'); // 获取 AI 服务下拉列表
        const undoGenBtn = document.getElementById('undo-gen-btn'); // 获取撤销按钮

        // Variable to store the range of the last AI generated text
        let lastGeneratedRange = null; 
        let isGenerating = false; // Flag to prevent concurrent generation requests

        // --- Function to handle the actual generation logic ---
        async function triggerGeneration() {
            if (isGenerating) {
                console.log('Generation already in progress, ignoring trigger.');
                return; // Prevent concurrent requests
            }
            isGenerating = true;
            generateBtn.disabled = true;
            undoGenBtn.disabled = true; // Also disable undo during generation
            generateBtn.textContent = '生成中...';
            lastGeneratedRange = null; // Reset undo state before new generation
            undoGenBtn.style.display = 'none';

            // Gather all necessary data
            const selectedTemplateId = templateSelect.value;
            const selectedAiServiceId = aiServiceSelect.value; 

            if (!selectedTemplateId) {
                alert('请先选择一个提示词模板！');
                isGenerating = false;
                generateBtn.disabled = false;
                generateBtn.textContent = '生成';
                return;
            }

            const templateId = parseInt(selectedTemplateId, 10);
            const editorContent = novelContent.value;
            const cursorPos = novelContent.selectionStart;
            const 前文 = editorContent.substring(0, cursorPos);
            const 后文 = editorContent.substring(cursorPos);
            const 提示词 = promptInput.value;
            const 字数 = parseInt(wordCountInput.value, 10) || 500;
            const 风格 = styleInput.value || '默认';
            const 设定 = [];
            const settingListElement = settingContent.querySelector('.setting-list');
            if (settingListElement) {
                const settingItems = settingListElement.querySelectorAll('.setting-item');
                settingItems.forEach(item => {
                    const checkbox = item.querySelector('.setting-enabled-toggle');
                    const textarea = item.querySelector('.setting-text-input');
                    if (checkbox && checkbox.checked && textarea && textarea.value.trim()) {
                        设定.push({ text: textarea.value.trim(), enabled: true });
                    }
                });
            }

            const requestData = {
                template_id: templateId,
                input_data: { '前文': 前文, '后文': 后文, '提示词': 提示词, '字数': 字数, '风格': 风格, '设定': 设定 }
            };
            if (selectedAiServiceId && selectedAiServiceId !== "") { 
                requestData.ai_service_config_id = parseInt(selectedAiServiceId, 10);
            } else {
                console.log("AI Service: Using user's default setting.");
            }

            console.log("准备发送到 /api/generate-with-template 的数据:", JSON.stringify(requestData, null, 2));

            let generatedText = null;
            try {
                const response = await fetch('/api/generate-with-template', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
                const result = await response.json();
                if (!response.ok) throw new Error(result.error || `HTTP error! status: ${response.status}`);
                if (result && result.generated_text) {
                   generatedText = result.generated_text;
                } else {
                   console.warn("API successful but no generated_text received.", result);
                   throw new Error('AI 服务未返回有效内容。');
               }
                 
                if (generatedText !== null && generatedText.length > 0) {
                    const currentContent = novelContent.value;
                    const selectionStart = novelContent.selectionStart;
                    const selectionEnd = novelContent.selectionEnd;
                    novelContent.value = currentContent.slice(0, selectionStart) + generatedText + currentContent.slice(selectionEnd);
                    const newCursorPos = selectionStart + generatedText.length;
                    novelContent.focus();
                    novelContent.setSelectionRange(newCursorPos, newCursorPos);
                    
                    lastGeneratedRange = { start: selectionStart, end: newCursorPos };
                    undoGenBtn.style.display = 'block'; 
                    undoGenBtn.disabled = false;
                    console.log('Generation successful, undo enabled for range:', lastGeneratedRange);
                    
                    novelContent.dispatchEvent(new Event('input', { bubbles: true }));
                } else {
                     lastGeneratedRange = null;
                     undoGenBtn.style.display = 'none';
                }
            } catch (error) {
                console.error('生成内容失败:', error);
                alert(`生成失败: ${error.message}`);
                lastGeneratedRange = null;
                undoGenBtn.style.display = 'none';
            } finally {
                 generateBtn.textContent = '生成';
                 generateBtn.disabled = false;
                 undoGenBtn.disabled = !lastGeneratedRange; // Disable undo if no valid range
                 isGenerating = false; // Release the lock
            }
        }

        // --- Add Listener for Prompt Input Enter Key ---
        if (promptInput && generateBtn) {
            promptInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault(); // Prevent default newline insertion
                    console.log('Enter pressed in prompt, triggering generation function...');
                    triggerGeneration(); // Call the generation function directly
                }
            });
        }

=======
        // --- Global/Module Scope Variable Declarations ---
        let fileList, contextMenu, createMenu, createBtn, deleteBtn, settingContent, novelContent;
        let rightSidebarTitle, bookTitleTextSpan, wordCountBadgeSpan, autoSaveToggle, centralDisplayArea, promptBar;
        let templateSelect, aiServiceSelect, wordCountInput, styleInput, promptInput, generateBtn, retryBtn, undoGenBtn, saveBtn; 
        let isGenerating = false;
>>>>>>> local
        let contextTarget = null;
        let draggedItemData = null;
        let currentDragTargetElement = null;
        let insertPosition = null;
        let currentEditingBookTitle = null;
        let isWordCountLimitAlertShown = false;
        let autoSaveTimer = null;
        const AUTO_SAVE_DELAY = 1500;
        let isAutoSaveOnNavigateEnabled = false;
        let generationPreviewArea, previewBefore, previewGenerated, previewAfter, applyGenerationBtn, cancelGenerationBtn; 
        let debounceSaveSettings = null;

        // --- Function Definitions --- 
        async function fetchAPI(url, options = {}) {
            const headers = {
                'Content-Type': 'application/json',
                'Accept': 'application/json',
                ...(options.headers || {}),
            };
            if (options.body && typeof options.body !== 'string') {
                options.body = JSON.stringify(options.body);
            }
            try {
                const response = await fetch(url, { ...options, headers });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Request failed with status: ' + response.status }));
                    console.error(`API Error (${response.status}): ${errorData.error || 'Unknown error'}`, url, options);
                    alert(`操作失败: ${errorData.error || '未知错误'}`); 
                    return null; 
                }
                if (response.status === 204 || response.headers.get('Content-Length') === '0') {
                     return { success: true }; 
                }
                return await response.json();
            } catch (error) {
                console.error('Network or fetch error:', error, url, options);
                alert('网络错误或请求失败');
                return null;
            }
        }

        async function fetchItems(parentId = 'root') {
            return await fetchAPI(`/api/items?parent_id=${parentId}`);
        }
        async function createItemAPI(name, type, parentId = 'root') {
            return await fetchAPI('/api/items', { method: 'POST', body: { name, type, parentId } });
        }
        async function deleteItemAPI(itemId) {
            return await fetchAPI(`/api/items/${itemId}`, { method: 'DELETE' });
        }
        async function renameItemAPI(itemId, newName) {
            return await fetchAPI(`/api/items/${itemId}/rename`, { method: 'PUT', body: { name: newName } });
        }
        async function moveItemAPI(itemId, targetParentId, targetBeforeId = null) {
            return await fetchAPI(`/api/items/${itemId}/move`, { method: 'PUT', body: { targetParentId, targetBeforeId } });
        }
        async function getContentAPI(itemId) {
             return await fetchAPI(`/api/items/${itemId}/content`);
        }
        async function updateContentAPI(itemId, type, data) {
            let body = {};
            if (type === 'book') {
                body = { content: data };
            } else if (type === 'setting') {
                body = { settings: data }; 
            }
            return await fetchAPI(`/api/items/${itemId}/content`, { method: 'PUT', body: body });
        }
        async function toggleFolderAPI(itemId, collapsed) {
            return await fetchAPI(`/api/items/${itemId}/toggle`, { method: 'PUT', body: { collapsed } });
        }
        async function associateSettingAPI(bookId, settingBookId) {
            return await fetchAPI(`/api/items/${bookId}/associate_setting`, { method: 'POST', body: { settingBookId } });
        }
        async function updateUserSettingAPI(settingKey, settingValue) {
            console.log(`Updating user setting via API: ${settingKey} = ${settingValue}`);
            return await fetchAPI('/api/user/settings', { method: 'PUT', body: { [settingKey]: settingValue } });
        }
        async function getUnassociatedBooksAPI() {
            return await fetchAPI('/api/books/unassociated');
        }

        function renderFileList(data, parentElement) {
            parentElement.innerHTML = '';
            if (!data || !Array.isArray(data)) {
                console.error("renderFileList received invalid data:", data);
                parentElement.innerHTML = '<li>加载失败或无数据</li>';
                return;
            }
            data.forEach(item => {
                const li = document.createElement('li');
                li.classList.add('file-item');
                li.dataset.id = item.id;
                li.dataset.type = item.type;
                if (item.type === 'folder' && item.collapsed) {
                    li.classList.add('collapsed');
                }
                li.draggable = true;

                let iconClass = '';
                let toggleIcon = '';
                if (item.type === 'folder') {
                    iconClass = 'fa-folder';
                    toggleIcon = `<i class="fas fa-chevron-right folder-toggle"></i>`;
                } else if (item.type === 'book') {
                    iconClass = 'fa-book';
                } else if (item.type === 'setting') {
                    iconClass = 'fa-scroll';
                }

                li.innerHTML = `
                    ${toggleIcon}
                    <i class="fas ${iconClass}"></i>
                    <span class="item-name">${item.name}</span>
                `;

                // Add listeners
                li.addEventListener('click', (event) => handleItemClick(event, item, li));
                li.addEventListener('contextmenu', (event) => showContextMenu(event, li, item));
                li.addEventListener('dragstart', (event) => handleDragStart(event, item, li));
                li.addEventListener('dragenter', (event) => handleDragEnter(event, item, li));
                li.addEventListener('dragover', (event) => handleDragOver(event, item, li));
                li.addEventListener('dragleave', (event) => handleDragLeave(event, li));
                li.addEventListener('drop', (event) => handleDrop(event, item, li));

                parentElement.appendChild(li);

                if (item.type === 'folder') {
                    const ul = document.createElement('ul');
                    ul.style.display = item.collapsed ? 'none' : 'block';
                    li.appendChild(ul);
                }
            });
        }
        async function loadInitialItems() {
            console.log("Loading initial items...");
            if (!fileList) {
                console.error("loadInitialItems: fileList element not available yet.");
                return;
            }
            const rootItems = await fetchItems('root');
            if (rootItems) {
                renderFileList(rootItems, fileList);
            } else {
                 fileList.innerHTML = '<li>加载根目录失败</li>';
            }
        }
        async function reloadItemsForParent(parentId) {
            const parentIdStr = parentId || 'root';
            console.log(`Reloading items for parent: ${parentIdStr}`);
            let targetUl;
            if (parentIdStr === 'root') {
                targetUl = fileList;
            } else {
                 const parentLi = fileList?.querySelector(`.file-item[data-id="${parentId}"]`);
                 if (parentLi) {
                     targetUl = parentLi.querySelector('ul');
                 } else {
                      console.error('Cannot find parent element to reload for id:', parentId);
                      return;
                 }
            }
            if (!targetUl) {
                 console.error('Cannot find target UL element for parent id:', parentId);
                 return;
            }
            const items = await fetchItems(parentIdStr);
            if (items) {
                 renderFileList(items, targetUl);
            } else {
                 targetUl.innerHTML = '<li><i>加载失败</i></li>';
            }
        }
        function displaySettingDetails(settingItem) {
             if (!settingContent) return;
             settingContent.innerHTML = ''; 
             const headerDiv = document.createElement('div');
             headerDiv.classList.add('setting-header');
             const titleH3 = document.createElement('h3');
             titleH3.textContent = settingItem.name;
             headerDiv.appendChild(titleH3);
             const actionsDiv = document.createElement('div');
             actionsDiv.classList.add('setting-actions');
             actionsDiv.innerHTML = `
                 <button id="add-setting-btn" title="添加新设定">+</button>
                 <button id="save-settings-btn" title="保存当前设定书的更改">保存设定</button>
             `;
             headerDiv.appendChild(actionsDiv);
             settingContent.appendChild(headerDiv);

             const settingList = document.createElement('ul');
             settingList.classList.add('setting-list');
             settingList.dataset.settingBookId = settingItem.id; 
             const settingsData = settingItem.settings || [];
             if (settingsData.length > 0) {
                 settingsData.forEach((setting, index) => {
                     const li = createSettingItemElement(setting, index);
                     settingList.appendChild(li);
                 });
              } else {
                 const placeholder = document.createElement('p');
                 placeholder.textContent = '暂无详细设定，点击 "+" 添加。';
                 placeholder.style.textAlign = 'center';
                 placeholder.style.color = '#6c757d';
                 placeholder.style.marginTop = '20px';
                 settingList.appendChild(placeholder);
             }
             settingContent.appendChild(settingList);
        }
        function createSettingItemElement(settingData, index) {
            const li = document.createElement('li');
            li.classList.add('setting-item');
            li.dataset.index = index;
            const text = settingData.text || '';
            const enabled = settingData.enabled !== undefined ? settingData.enabled : true;
            li.innerHTML = `
                <div class="setting-item-controls">
                    <input type="checkbox" class="setting-enabled-toggle" ${enabled ? 'checked' : ''} title="是否启用此设定">
                </div>
                <textarea class="setting-text-input" rows="1">${text}</textarea>
                <div class="setting-item-controls">
                     <button class="delete-setting-btn" title="删除此设定">-</button>
                </div>
            `;
            const textarea = li.querySelector('.setting-text-input');
            adjustTextareaHeight(textarea);
            textarea.addEventListener('input', () => adjustTextareaHeight(textarea));
            return li;
        }
        function adjustTextareaHeight(textarea) {
            if (!textarea) return;
            textarea.style.height = 'auto';
            textarea.style.height = textarea.scrollHeight + 'px';
        }
        function clearSettingDisplay() {
             if (!settingContent) return;
             settingContent.innerHTML = `<p>点击左侧设定书查看详情</p>`;
             delete settingContent.dataset.currentItemId;
             delete settingContent.dataset.currentItemType;
             delete settingContent.dataset.settingBookId; 
             currentEditingBookTitle = null;
             isWordCountLimitAlertShown = false;
             updateRightSidebarTitle('设定详情');
        }
        function countCharacters(text) {
            return text ? text.length : 0;
        }
        function updateRightSidebarTitle(title, content = null) {
            const maxChars = 25000;
            if (!bookTitleTextSpan || !wordCountBadgeSpan) {
                 console.error("updateRightSidebarTitle: Cannot find title or badge span elements.");
                 if (rightSidebarTitle) rightSidebarTitle.textContent = title; // Fallback
                 return;
            }
            bookTitleTextSpan.textContent = title;
            if (content !== null && title !== '设定详情') {
                 const charCount = countCharacters(content);
                 wordCountBadgeSpan.textContent = `(${charCount} / ${maxChars} 字)`;
                 wordCountBadgeSpan.style.display = 'inline-block';
                const isOverLimit = charCount > maxChars;
                if (isOverLimit) {
                    wordCountBadgeSpan.classList.add('limit-exceeded');
                    if (!isWordCountLimitAlertShown) {
                        alert(`字数（字符数）已超过 ${maxChars} 字上限！当前 ${charCount} 字。`);
                        isWordCountLimitAlertShown = true;
                    }
                } else {
                    wordCountBadgeSpan.classList.remove('limit-exceeded');
                    isWordCountLimitAlertShown = false;
                }
            } else {
                wordCountBadgeSpan.style.display = 'none';
                wordCountBadgeSpan.classList.remove('limit-exceeded');
                isWordCountLimitAlertShown = false;
            }
        }
        async function populateTemplateSelector() {
            if (!templateSelect) {
                console.error('populateTemplateSelector called but templateSelect element is null.');
                return;
            }
            try {
                const response = await fetch('/api/prompt-templates');
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                const templates = await response.json();
                templateSelect.innerHTML = '<option value="">-- 选择模板 --</option>';
                templates.forEach(template => {
                     const option = document.createElement('option');
                     option.value = template.id;
                     option.textContent = template.name;
                    if (template.is_default) option.selected = true;
                    templateSelect.appendChild(option);
                });
            } catch (error) {
                console.error('获取模板列表失败:', error);
                templateSelect.innerHTML = '<option value="">加载模板失败</option>'; 
            }
        }
        async function populateAiServiceSelector() {
             if (!aiServiceSelect) {
                 console.error('populateAiServiceSelector called but aiServiceSelect element is null.');
                 return;
             }
             try {
                 const response = await fetch('/api/ai-services/available');
                 if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                 const services = await response.json();
                 aiServiceSelect.innerHTML = '<option value="">-- 使用默认 --</option>';
                 services.forEach(service => {
                     const option = document.createElement('option');
                     option.value = service.id;
                     option.textContent = service.name;
                     aiServiceSelect.appendChild(option);
                 });
             } catch (error) {
                 console.error('获取可用 AI 服务列表失败:', error);
                 aiServiceSelect.innerHTML = '<option value="">加载服务失败</option>';
             }
         }
        function renderUnassociatedBookList(books, settingBookId, containerElement) {
            if (!containerElement) return;
            containerElement.innerHTML = ''; 
            const title = document.createElement('h4');
            const settingItem = fileList?.querySelector(`.file-item[data-id="${settingBookId}"]`);
            const settingName = settingItem ? settingItem.querySelector('.item-name').textContent : '此设定书';
            title.textContent = `将《${settingName}》关联到哪本书籍？`;
            containerElement.appendChild(title);
            if (!books || books.length === 0) {
                containerElement.innerHTML += '<p style="color: #6c757d;">没有找到未关联任何设定书的书籍。</p>';
                return;
            }
            const ul = document.createElement('ul');
            ul.classList.add('unassociated-book-list');
            ul.dataset.settingBookId = settingBookId;
            books.forEach(book => {
                const li = document.createElement('li');
                li.classList.add('unassociated-book-item');
                li.dataset.bookId = book.id;
                li.innerHTML = `<i class="fas fa-book"></i> <span>${book.name}</span>`;
                li.addEventListener('click', (event) => handleAssociateAndOpenBook(event, settingBookId));
                ul.appendChild(li);
            });
            containerElement.appendChild(ul);
        }
        function showEditorArea() {
            if (generationPreviewArea) generationPreviewArea.style.display = 'none';
            if (centralDisplayArea) centralDisplayArea.style.display = 'none';
             const editorAreaContainer = document.querySelector('.novel-editor-area');
             if (editorAreaContainer && window.getComputedStyle(editorAreaContainer).display === 'none') {
                 editorAreaContainer.style.display = 'flex';
             }
            if (novelContent) novelContent.style.display = 'block';
            if (promptBar) promptBar.style.display = 'flex';
            console.log('[Display Control] Showing Editor Area (and hiding preview/central)');
        }
        function showCentralDisplay() {
             if (generationPreviewArea) generationPreviewArea.style.display = 'none';
             if (novelContent) novelContent.style.display = 'none';
             if (promptBar) promptBar.style.display = 'none';
             const editorAreaContainer = document.querySelector('.novel-editor-area');
             if (editorAreaContainer) editorAreaContainer.style.display = 'none';
             if (centralDisplayArea) {
                 centralDisplayArea.innerHTML = '<div><i>加载中...</i></div>';
                 centralDisplayArea.style.display = 'block';
             }
             console.log('[Display Control] Showing Central Display Area (and hiding editor/preview)');
        }
        function showGenerationPreviewArea() {
            if (novelContent) novelContent.style.display = 'none';
            if (promptBar) promptBar.style.display = 'none';
            if (centralDisplayArea) centralDisplayArea.style.display = 'none';
            if (generationPreviewArea) generationPreviewArea.style.display = 'flex';
            console.log('[Display Control] Showing Generation Preview Area');
        }
        function showContextMenu(event, element, item) {
            event.preventDefault();
            event.stopPropagation();
            contextTarget = { element, item };
            if (!contextMenu) return;
            contextMenu.style.top = `${event.clientY}px`;
            contextMenu.style.left = `${event.clientX}px`;
            contextMenu.style.display = 'block';
        }
        function hideContextMenu() {
            if (contextMenu) contextMenu.style.display = 'none';
            contextTarget = null;
        }
        function showCreateMenu(event) {
             event.stopPropagation();
             if (!createBtn || !createMenu) return;
             const rect = createBtn.getBoundingClientRect();
             createMenu.style.top = `${rect.bottom + 5}px`;
             createMenu.style.left = `${rect.left}px`;
             createMenu.style.display = 'block';
        }
        function hideCreateMenu() {
            if (createMenu) createMenu.style.display = 'none';
        }
        function cleanupAiMarkup() { /* Temporarily disabled */ return false; }
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        async function handleItemClick(event, itemData, itemElement) {
            event.stopPropagation();
            console.log('Clicked:', itemData.name, 'Type:', itemData.type);
            const previouslyEditingItemId = novelContent?.dataset.currentItemId;
            const previouslyEditingItemType = novelContent?.dataset.currentItemType;
            if (isAutoSaveOnNavigateEnabled && previouslyEditingItemId && previouslyEditingItemType === 'book' && previouslyEditingItemId !== String(itemData.id)) {
                 console.log(`[AutoSave Navigate] Triggering save for book ${previouslyEditingItemId} before switching to ${itemData.name}`);
                 if (autoSaveTimer) {
                     clearTimeout(autoSaveTimer);
                     autoSaveTimer = null;
                     console.log('[AutoSave Navigate] Cleared pending input auto-save timer.');
                 }
                 await saveCurrentBookContent();
                 console.log(`[AutoSave Navigate] Save completed for ${previouslyEditingItemId}.`);
            }
            currentEditingBookTitle = null;
            isWordCountLimitAlertShown = false;
            if (itemData.type === 'folder') {
                showEditorArea();
                if(novelContent) novelContent.value = '';
                delete novelContent?.dataset.currentItemId;
                delete novelContent?.dataset.currentItemType;
                clearSettingDisplay(); 
                updateRightSidebarTitle('设定详情'); 
                const folderId = itemData.id;
                const isCollapsed = itemElement.classList.toggle('collapsed');
                const childrenUl = itemElement.querySelector('ul');
                await toggleFolderAPI(folderId, isCollapsed);
                if (!isCollapsed && childrenUl && childrenUl.children.length === 0) {
                    console.log(`Fetching children for folder ${folderId}...`);
                    childrenUl.innerHTML = '<li><i>加载中...</i></li>';
                    const childrenData = await fetchItems(folderId);
                    if (childrenData) renderFileList(childrenData, childrenUl);
                    else childrenUl.innerHTML = '<li><i>加载失败</i></li>';
                }
                if (childrenUl) childrenUl.style.display = isCollapsed ? 'none' : 'block';
            } else if (itemData.type === 'book') {
                await openBook(itemData);
            } else if (itemData.type === 'setting') {
                console.log(`[Setting Click] Handling click for setting: ${itemData.name}`);
                if(novelContent) novelContent.value = '';
                delete novelContent?.dataset.currentItemId;
                delete novelContent?.dataset.currentItemType;
                clearSettingDisplay(); 
                updateRightSidebarTitle('设定详情'); 
                const settingDetails = await getContentAPI(itemData.id);
                if (settingDetails && settingDetails.associatedBookInfo) {
                    console.log(`[Setting Click] Setting ${itemData.name} is associated with Book ID: ${settingDetails.associatedBookInfo.id}`);
                    await openBook(settingDetails.associatedBookInfo);
                } else if (settingDetails) {
                    console.log(`[Setting Click] Setting ${itemData.name} is not associated. Fetching unassociated books...`);
                    showCentralDisplay();
                    const unassociatedBooks = await getUnassociatedBooksAPI();
                    if (unassociatedBooks) renderUnassociatedBookList(unassociatedBooks, itemData.id, centralDisplayArea);
                    else if (centralDisplayArea) centralDisplayArea.innerHTML = '<h4>关联书籍</h4><p>加载未关联书籍列表失败。</p>';
                    clearSettingDisplay(); 
                    updateRightSidebarTitle(`关联《${itemData.name}》`);
                } else {
                    console.error(`[Setting Click] Failed to get details for setting ${itemData.name}.`);
                    showEditorArea(); 
                    alert('加载设定书信息失败。');
                }
            }
        }
        async function openBook(bookData) {
             console.log(`[Open Book] Opening book: ${bookData.name} (ID: ${bookData.id})`);
             showEditorArea(); 
             console.log('[Open Book] After showEditorArea - novelContent display:', novelContent ? window.getComputedStyle(novelContent).display : 'Not Found');
             console.log('[Open Book] After showEditorArea - centralDisplayArea display:', centralDisplayArea ? window.getComputedStyle(centralDisplayArea).display : 'Not Found');
             clearSettingDisplay(); 
             if(novelContent) novelContent.value = '加载中...'; 
             novelContent.dataset.currentItemId = bookData.id;
             novelContent.dataset.currentItemType = 'book';
             currentEditingBookTitle = bookData.name; 
             isWordCountLimitAlertShown = false; 
             updateRightSidebarTitle(currentEditingBookTitle); 
             const contentData = await getContentAPI(bookData.id);
             console.log("[Open Book] Received content data:", contentData);
             if (contentData) {
                 if(novelContent) novelContent.value = contentData.content || '';
                 updateRightSidebarTitle(currentEditingBookTitle, novelContent.value);
                 if (contentData.associatedSetting) {
                     console.log('[Open Book] Book has associated setting, displaying...', contentData.associatedSetting);
                     const fullSettingData = await getContentAPI(contentData.associatedSetting.id);
                     if (fullSettingData) {
                         displaySettingDetails(fullSettingData); 
                         settingContent.dataset.currentItemId = fullSettingData.id;
                         settingContent.dataset.currentItemType = 'setting';
                     } else {
                          console.error('[Open Book] Failed to fetch full details for associated setting.');
                          clearSettingDisplay(); 
                     }
                 } else {
                     console.log('[Open Book] Book does not have an associated setting.');
                     clearSettingDisplay(); 
                 }
             } else {
                 console.error('[Open Book] Failed to fetch content data.');
                 if(novelContent) novelContent.value = '加载内容失败。';
                 delete novelContent?.dataset.currentItemId;
                 delete novelContent?.dataset.currentItemType;
                 updateRightSidebarTitle(bookData.name); 
                 currentEditingBookTitle = null;
                 isWordCountLimitAlertShown = false;
                 clearSettingDisplay();
             }
             console.log("[Open Book] Finished opening book.");
         }
        function startRename(target) {
            if (!target || !target.element) return;
            const itemNameSpan = target.element.querySelector('.item-name');
            if (!itemNameSpan) return;
            const currentName = target.item.name;
            const itemId = target.item.id;
            const input = document.createElement('input');
            input.type = 'text';
            input.value = currentName;
            input.classList.add('rename-input');
            itemNameSpan.replaceWith(input);
            input.focus();
            input.select();
            const finishRename = async (save) => {
                 const newName = input.value.trim();
                input.removeEventListener('blur', onBlur);
                input.removeEventListener('keydown', onKeydown);
                if (save && newName && newName !== currentName) {
                    console.log(`Renaming item ${itemId} to ${newName}...`);
                    const updatedItem = await renameItemAPI(itemId, newName);
                    if (updatedItem) {
                        const newSpan = document.createElement('span');
                        newSpan.classList.add('item-name');
                        newSpan.textContent = updatedItem.name;
                        input.replaceWith(newSpan);
                        target.item.name = updatedItem.name;
                    } else {
                         input.replaceWith(itemNameSpan);
                         alert('重命名失败');
                    }
                } else {
                    input.replaceWith(itemNameSpan);
                }
            };
            const onBlur = () => finishRename(true);
            const onKeydown = (e) => {
                if (e.key === 'Enter') finishRename(true);
                else if (e.key === 'Escape') finishRename(false);
             };
            input.addEventListener('blur', onBlur);
            input.addEventListener('keydown', onKeydown);
        }
        async function deleteItem(targetItemData) {
<<<<<<< 初步稳定版
            const itemName = targetItemData.name;
            const itemId = targetItemData.id;
            const itemType = targetItemData.type;

            if (confirm(`确定要删除 ${itemName} 吗？` + (itemType === 'folder' ? ' (其内容也将被删除)' : ''))) {
                console.log(`Deleting item ${itemId}...`);
                const result = await deleteItemAPI(itemId);
                if (result !== null) { 
                    console.log(`Item ${itemId} deleted successfully (API call successful).`);
                    // 从界面移除元素
                    const elementSelector = `.file-item[data-id="${itemId}"]`;
                    console.log(`Attempting to find element with selector: ${elementSelector}`);
                    const elementToRemove = fileList.querySelector(elementSelector);
                    console.log("Element to remove found in DOM:", elementToRemove);
                    if (elementToRemove) {
                        console.log("Removing element from UI...");
                        elementToRemove.remove();
                    } else {
                         console.warn("Could not find element in DOM to remove.");
                    }
                    // 如果删除的是当前显示/编辑的项
                    if (novelContent.dataset.currentItemId == itemId) {
                         novelContent.value = '';
                         delete novelContent.dataset.currentItemId;
                         delete novelContent.dataset.currentItemType;
                         // *** 修改点：重置标题和全局变量 ***
                         currentEditingBookTitle = null;
                         isWordCountLimitAlertShown = false; // Reset flag
                         updateRightSidebarTitle('设定详情');
                         clearSettingDisplay();
                    }
                    if (settingContent.dataset.currentItemId == itemId) {
                         currentEditingBookTitle = null;
                         isWordCountLimitAlertShown = false; // Reset flag
                         clearSettingDisplay();
                    }
                } else {
                     // result 为 null，表示 fetchAPI 内部出错 (已 alert)
                     console.error(`Failed to delete item ${itemId} (API call failed).`);
                }
            }
=======
             const itemName = targetItemData.name;
             const itemId = targetItemData.id;
             const itemType = targetItemData.type;
             const originalParentId = targetItemData.parent_id || 'root';
             if (confirm(`确定要删除 ${itemName} 吗？` + (itemType === 'folder' ? ' (其内容也将被删除)' : ''))) {
                 console.log(`Deleting item ${itemId}...`);
                 const result = await deleteItemAPI(itemId);
                 if (result !== null) { 
                     console.log(`Item ${itemId} deleted successfully (API call successful).`);
                     const elementSelector = `.file-item[data-id="${itemId}"]`;
                     const elementToRemove = fileList?.querySelector(elementSelector);
                     if (elementToRemove) elementToRemove.remove();
                     else console.warn("Could not find element in DOM to remove.");
                     if (novelContent?.dataset.currentItemId == itemId) {
                          if(novelContent) novelContent.value = ''; 
                          delete novelContent?.dataset.currentItemId;
                          delete novelContent?.dataset.currentItemType;
                          currentEditingBookTitle = null;
                          isWordCountLimitAlertShown = false; 
                          updateRightSidebarTitle('设定详情');
                          clearSettingDisplay();
                     }
                     if (settingContent?.dataset.currentItemId == itemId) {
                          clearSettingDisplay();
                     }
                     console.log(`Refreshing original parent list (${originalParentId}) after deletion.`);
                     await reloadItemsForParent(originalParentId === 'root' ? null : originalParentId);
                 } else {
                      console.error(`Failed to delete item ${itemId} (API call failed).`);
                 }
             }
>>>>>>> local
        }
        async function createNewItem(type) {
             const defaultName = `新${type === 'folder' ? '文件夹' : type === 'book' ? '书籍' : '设定书'}`;
             const parentId = 'root';
             console.log(`Creating new ${type} named ${defaultName} under parent ${parentId}...`);
             const newItemData = await createItemAPI(defaultName, type, parentId);
             if (newItemData) {
                 console.log('Item created:', newItemData);
                 await loadInitialItems(); 
                 setTimeout(() => {
                    const newElement = fileList?.querySelector(`.file-item[data-id="${newItemData.id}"]`);
             if (newElement) {
                         startRename({ element: newElement, item: newItemData });
                    }
                 }, 100);
             } else {
                 console.error('Failed to create new item.');
             }
        }
        async function saveCurrentBookContent() {
            const currentId = novelContent?.dataset.currentItemId;
            const currentType = novelContent?.dataset.currentItemType;
            // Check saveBtn existence inside, as it might not be ready during initial calls
            const saveBtnElem = document.getElementById('save-btn'); 

            if (saveBtnElem && saveBtnElem.classList.contains('save-success')) {
                saveBtnElem.classList.remove('save-success');
            }
            if (currentId && currentType === 'book') {
                console.log(`[Save Trigger] Saving content for book ${currentId}...`);
                if (saveBtnElem) {
                    saveBtnElem.disabled = true;
                    saveBtnElem.textContent = '保存中...';
                }
                const contentToSave = novelContent.value;
                const result = await updateContentAPI(currentId, currentType, contentToSave);
                if (saveBtnElem) {
                    saveBtnElem.disabled = false;
                    saveBtnElem.textContent = '保存'; 
                }
                if (result) {
                    console.log('[Save Success] Content saved successfully.');
                    if (saveBtnElem) {
                        saveBtnElem.classList.add('save-success');
                        setTimeout(() => { saveBtnElem.classList.remove('save-success'); }, 1500); 
                    }
                    updateRightSidebarTitle(currentEditingBookTitle, novelContent.value);
                } else {
                     console.error('[Save Failed] Failed to save content.');
                     if (saveBtnElem) {
                        saveBtnElem.textContent = '保存失败!';
                         setTimeout(() => { if (!saveBtnElem.disabled) saveBtnElem.textContent = '保存'; }, 2000);
                     }
                }
            } else {
                console.log('[Save Skipped] No book selected or not editing a book.');
            }
        }
        async function triggerGeneration() {
            if (isGenerating || !generateBtn) return;
            isGenerating = true;
            generateBtn.disabled = true;
            generateBtn.textContent = '生成中...';
            const editorContent = novelContent?.value || '';
            const cursorPos = novelContent?.selectionStart || 0;
            const beforeText = editorContent.substring(0, cursorPos);
            const afterText = editorContent.substring(cursorPos);
            const templateId = parseInt(templateSelect?.value || '', 10);
            const aiServiceId = aiServiceSelect?.value;
            const 提示词 = promptInput?.value || '';
            const 字数 = parseInt(wordCountInput?.value || '500', 10);
            const 风格 = styleInput?.value || '默认';
            const 设定 = [];
             const settingListElement = settingContent?.querySelector('.setting-list');
             if (settingListElement) {
                 const settingItems = settingListElement.querySelectorAll('.setting-item');
                 settingItems.forEach(item => {
                     const checkbox = item.querySelector('.setting-enabled-toggle');
                     const textarea = item.querySelector('.setting-text-input');
                     if (checkbox && checkbox.checked && textarea && textarea.value.trim()) {
                         设定.push({ text: textarea.value.trim(), enabled: true });
                     }
                 });
             }
            if (!templateId) {
                 alert('请先选择一个提示词模板！');
                 isGenerating = false;
                 if(generateBtn) {
                     generateBtn.disabled = false;
                     generateBtn.textContent = '生成';
                 }
                 return;
            }
            const requestData = { template_id: templateId, input_data: { '前文': beforeText, '后文': afterText, '提示词': 提示词, '字数': 字数, '风格': 风格, '设定': 设定 } };
            if (aiServiceId && aiServiceId !== "") requestData.ai_service_config_id = parseInt(aiServiceId, 10);
            console.log("准备发送到 /api/generate-with-template 的数据:", JSON.stringify(requestData, null, 2));
            let generatedText = null;
            try {
                const response = await fetch('/api/generate-with-template', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(requestData) });
                const result = await response.json();
                if (!response.ok) throw new Error(result.error || `HTTP error! status: ${response.status}`);
                if (result && result.generated_text) generatedText = result.generated_text;
                else throw new Error('AI 服务未返回有效内容。');
                if (generatedText !== null) {
                    console.log('Generation successful, showing preview.');
                    if(previewBefore) previewBefore.value = beforeText;
                    if(previewGenerated) previewGenerated.value = generatedText;
                    if(previewAfter) previewAfter.value = afterText;
                    showGenerationPreviewArea();
                } else {
                    alert('AI 服务返回了空内容。');
                }
            } catch (error) {
                console.error('生成内容失败:', error);
                alert(`生成失败: ${error.message}`);
                showEditorArea();
            } finally {
                 if(generateBtn) {
                     generateBtn.textContent = '生成';
                     generateBtn.disabled = false;
                 }
                 isGenerating = false;
            }
        }
        async function autoSaveSettings() {
            const settingList = settingContent?.querySelector('.setting-list');
            const settingBookId = settingList ? settingList.dataset.settingBookId : null;
            const saveButton = document.getElementById('save-settings-btn');
            if (settingList && settingBookId) {
                 console.log(`[AutoSave Settings] Triggered for setting book ${settingBookId}.`);
                 const updatedSettings = [];
                 const settingItems = settingList.querySelectorAll('.setting-item');
                 settingItems.forEach(item => {
                     const textarea = item.querySelector('.setting-text-input');
                     const checkbox = item.querySelector('.setting-enabled-toggle');
                     if (textarea && checkbox) updatedSettings.push({ text: textarea.value, enabled: checkbox.checked });
                 });
                 if(saveButton && !saveButton.disabled) saveButton.textContent = '自动保存中...';
                 const result = await updateContentAPI(settingBookId, 'setting', updatedSettings);
                 if(saveButton && !saveButton.disabled) {
                    if (result) {
                         console.log('[AutoSave Settings] Success.');
                         saveButton.textContent = '已自动保存 ✓';
                         setTimeout(() => { if (!saveButton.disabled) saveButton.textContent = '保存设定'; }, 1500);
                     } else {
                         console.error('[AutoSave Settings] Failed.');
                         saveButton.textContent = '自动保存失败!';
                         setTimeout(() => { if (!saveButton.disabled) saveButton.textContent = '保存设定'; }, 2000);
                     }
                 }
            } else {
                 console.log('[AutoSave Settings] Skipped: No active setting book ID found.');
            }
        }
        async function handleAssociateAndOpenBook(event, settingBookId) {
            const clickedLi = event.currentTarget;
            const bookId = clickedLi.dataset.bookId;
            const bookName = clickedLi.querySelector('span')?.textContent || '未知书籍';
            console.log(`[Associate Click] Associating Setting ${settingBookId} with Book ${bookId} (${bookName})...`);
            const listElement = clickedLi.closest('.unassociated-book-list');
            if(listElement) listElement.style.pointerEvents = 'none';
            clickedLi.style.backgroundColor = '#d1e7dd';
            clickedLi.innerHTML += ' <i>关联中...</i>';
            const result = await associateSettingAPI(bookId, settingBookId);
            if (result && result.id == bookId) {
                console.log('[Associate Click] Association successful.');
                const bookData = { id: bookId, name: bookName, type: 'book' }; 
                await openBook(bookData);
            } else {
                 console.error('[Associate Click] Association failed.');
                 alert('关联失败，请重试。');
                 if(listElement) listElement.style.pointerEvents = 'auto';
                 clickedLi.style.backgroundColor = '';
                 clickedLi.querySelector('i:last-child')?.remove();
            }
        }
        // Drag and Drop Handlers (handleDragStart, handleDragEnter, handleDragOver, handleDragLeave, handleDrop, cleanupDragState, clearDropClasses) 
        // ... (Keep existing drag/drop function definitions here, ensure they check element existence if needed) ...
        function handleDragStart(event, itemData, element) { /* ... */ }
        function handleDragEnter(event, targetItemData, targetElement) { /* ... */ }
        function handleDragOver(event, targetItemData, targetElement) { /* ... */ }
        function handleDragLeave(event, element) { /* ... */ }
        async function handleDrop(event, targetItemData, targetElement) { /* ... */ }
        function cleanupDragState() { /* ... */ }
        function clearDropClasses(excludeElement = null) { /* ... */ }

        // --- Initialization Code --- 
        document.addEventListener('DOMContentLoaded', () => {
            // Assign element references
            fileList = document.getElementById('file-list');
            contextMenu = document.getElementById('context-menu');
            createMenu = document.getElementById('create-menu');
            createBtn = document.getElementById('create-btn');
            deleteBtn = document.getElementById('delete-btn');
            settingContent = document.getElementById('setting-content');
            novelContent = document.getElementById('novel-content'); 
            rightSidebarTitle = document.getElementById('right-sidebar-title');
            bookTitleTextSpan = rightSidebarTitle?.querySelector('.book-title-text');
            wordCountBadgeSpan = rightSidebarTitle?.querySelector('.word-count-badge');
            autoSaveToggle = document.getElementById('auto-save-toggle');
            centralDisplayArea = document.getElementById('central-display-area');
            promptBar = document.querySelector('.prompt-bar');
            generationPreviewArea = document.getElementById('generation-preview-area');
            previewBefore = document.getElementById('preview-before');
            previewGenerated = document.getElementById('preview-generated');
            previewAfter = document.getElementById('preview-after');
            applyGenerationBtn = document.getElementById('apply-generation-btn');
            cancelGenerationBtn = document.getElementById('cancel-generation-btn');

            // --- Detailed Prompt Bar Element Assignment with Logging ---
            console.log('DOMContentLoaded: Attempting to find prompt bar elements...');
            
            console.log('Finding templateSelect...');
            templateSelect = document.getElementById('template-select');
            console.log('templateSelect found:', templateSelect);

            console.log('Finding aiServiceSelect...');
            aiServiceSelect = document.getElementById('ai-service-select');
            console.log('aiServiceSelect found:', aiServiceSelect);

            console.log('Finding wordCountInput...');
            wordCountInput = document.getElementById('word-count-input');
            console.log('wordCountInput found:', wordCountInput);

            console.log('Finding styleInput...');
            styleInput = document.getElementById('style-input');
            console.log('styleInput found:', styleInput);

            console.log('Finding promptInput...');
            promptInput = document.querySelector('.prompt-input');
            console.log('promptInput found:', promptInput);

            console.log('Finding generateBtn...');
            generateBtn = document.getElementById('generate-btn');
            console.log('generateBtn found:', generateBtn);

            console.log('Finding retryBtn...');
            retryBtn = document.getElementById('retry-btn');
            console.log('retryBtn found:', retryBtn);
            
            console.log('Finding undoGenBtn...'); // Should likely be null or hidden
            undoGenBtn = document.getElementById('undo-gen-btn');
            console.log('undoGenBtn found:', undoGenBtn); 

            console.log('Finding saveBtn...');
            saveBtn = document.getElementById('save-btn');
            console.log('saveBtn found:', saveBtn);
            console.log('Finished finding prompt bar elements.');
            // --- End Detailed Logging ---

            // Element existence checks (These will now reflect the detailed findings)
            if (!fileList) console.error("DOM Init Error: fileList not found!");
            // ... (Include ALL other checks as before, including the prompt bar ones) ...
            if (!templateSelect) console.error("DOM Init Error: templateSelect not found! Cannot populate templates.");
            if (!aiServiceSelect) console.error("DOM Init Error: aiServiceSelect not found! Cannot populate AI services.");
            if (!wordCountInput) console.error("DOM Init Error: wordCountInput not found!");
            if (!styleInput) console.error("DOM Init Error: styleInput not found!");
            if (!promptInput) console.error("DOM Init Error: promptInput not found!");
            if (!generateBtn) console.error("DOM Init Error: generateBtn not found!");
            if (!retryBtn) console.warn("DOM Init Warning: retryBtn not found!");
            if (!undoGenBtn) console.warn("DOM Init Warning: undoGenBtn not found!"); // This might be expected now
            if (!saveBtn) console.error("DOM Init Error: saveBtn not found!");

            // Initial data loading
            if (fileList) loadInitialItems(); 
            if (templateSelect) populateTemplateSelector();
            if (aiServiceSelect) populateAiServiceSelector();

            // Setup Auto-Save Toggle
            if (autoSaveToggle) {
                let initialAutoSaveSetting = null;
                try {
                    const initialStateString = autoSaveToggle.dataset.initialState;
                    if (initialStateString === 'true') initialAutoSaveSetting = true;
                    else if (initialStateString === 'false') initialAutoSaveSetting = false;
                } catch (e) { console.error("Error reading initial auto-save setting:", e); }
                if (typeof initialAutoSaveSetting === 'boolean') {
                    isAutoSaveOnNavigateEnabled = initialAutoSaveSetting;
                    autoSaveToggle.checked = isAutoSaveOnNavigateEnabled;
                    console.log('Initial Auto-save on navigate away (from data):', isAutoSaveOnNavigateEnabled ? 'Enabled' : 'Disabled');
                } else {
                    isAutoSaveOnNavigateEnabled = autoSaveToggle.checked;
                    console.warn('Initial auto-save setting not received/invalid, using default.')
                    console.log('Initial Auto-save on navigate away (default):', isAutoSaveOnNavigateEnabled ? 'Enabled' : 'Disabled');
                }
                autoSaveToggle.addEventListener('change', async () => {
                    isAutoSaveOnNavigateEnabled = autoSaveToggle.checked;
                    console.log('Auto-save on navigate away toggled:', isAutoSaveOnNavigateEnabled ? 'Enabled' : 'Disabled');
                    const result = await updateUserSettingAPI('auto_save_on_navigate', isAutoSaveOnNavigateEnabled);
                    if (!result || !result.success) {
                         console.error('Failed to update user setting.');
                         autoSaveToggle.checked = !isAutoSaveOnNavigateEnabled;
                         isAutoSaveOnNavigateEnabled = !isAutoSaveOnNavigateEnabled;
                         alert('无法保存设置，请稍后重试。');
                    }
                });
            }

            // Hide preview area initially
             if (generationPreviewArea) generationPreviewArea.style.display = 'none';

            // Add Event Listeners
            if (saveBtn) saveBtn.addEventListener('click', async () => { if (autoSaveTimer) clearTimeout(autoSaveTimer); autoSaveTimer = null; await saveCurrentBookContent(); });
            if (generateBtn) generateBtn.addEventListener('click', triggerGeneration);
            if (retryBtn) retryBtn.addEventListener('click', () => alert('"重试"功能待实现'));
            if (undoGenBtn) undoGenBtn.style.display = 'none';
            if (applyGenerationBtn) applyGenerationBtn.addEventListener('click', async () => { 
                console.log('Apply button clicked.');
                if (!previewBefore || !previewGenerated || !previewAfter || !novelContent) return;
                const combinedText = previewBefore.value + previewGenerated.value + previewAfter.value;
                novelContent.value = combinedText;
                showEditorArea();
                novelContent.dispatchEvent(new Event('input', { bubbles: true }));
                console.log('Triggering save after applying generation...');
                await saveCurrentBookContent(); 
            });
<<<<<<< 初步稳定版

            // --- 生成按钮事件监听 --- 
             if (generateBtn) {
                 generateBtn.addEventListener('click', triggerGeneration); // Call the generation function on click
                 /* --- Original click listener code moved to triggerGeneration() --- */
                 /* generateBtn.addEventListener('click', async () => { ... }); */
             } else {
                 console.error("Generate button not found!");
             }
             
            // --- Add Undo Button Listener ---
            if (undoGenBtn) {
                 undoGenBtn.addEventListener('click', () => {
                     if (lastGeneratedRange) {
                         console.log('Undo clicked, removing range:', lastGeneratedRange);
                         const currentValue = novelContent.value;
                         const range = lastGeneratedRange;
                         
                         // Remove the text
                         novelContent.value = currentValue.slice(0, range.start) + currentValue.slice(range.end);
                         
                         // Move cursor back to the start of the removed range
                         novelContent.focus();
                         novelContent.setSelectionRange(range.start, range.start);
                         
                         // Reset state
                         lastGeneratedRange = null;
                         undoGenBtn.style.display = 'none';
                         
                         // Trigger input event to update counts etc.
                         novelContent.dispatchEvent(new Event('input', { bubbles: true }));
                         
                         // Optional: Trigger auto-save after undo
                         // if (debounceSaveSettings) debounceSaveSettings(); 
                     } else {
                         console.warn('Undo clicked but no valid range stored.');
                         undoGenBtn.style.display = 'none'; // Hide if somehow visible without range
                     }
                 });
            } else {
                console.error('Undo Generate button not found!');
            }

            // --- Modify Save Logic --- 
            async function saveCurrentBookContent() {
                const currentId = novelContent.dataset.currentItemId;
                const currentType = novelContent.dataset.currentItemType;
                const saveBtn = document.getElementById('save-btn'); 
                
                // --- Disable undo when saving --- 
                if (lastGeneratedRange) {
                    console.log('Saving content, disabling undo.');
                    lastGeneratedRange = null;
                    undoGenBtn.style.display = 'none'; 
                }
                // --- End disable undo --- 
                
                let wasTriggeredByInput = false; 

                if (saveBtn && saveBtn.classList.contains('save-success')) {
                    // 如果按钮已经是成功状态，可能快速连续触发，先移除旧状态
                    saveBtn.classList.remove('save-success');
                }

                if (currentId && currentType === 'book') {
                    console.log(`[Save Trigger] Saving content for book ${currentId}...`);
                    // 可选：添加一个不那么干扰的保存状态指示，例如在标题旁边
                    // wordCountBadgeSpan.textContent = '保存中...';

                    if (saveBtn) { // 临时禁用手动保存按钮防止冲突
                        saveBtn.disabled = true;
                        saveBtn.textContent = '保存中...';
                    }

                    const result = await updateContentAPI(currentId, currentType, novelContent.value);

                    if (saveBtn) { // 恢复按钮
                        saveBtn.disabled = false;
                        saveBtn.textContent = '保存'; // 恢复原始文本
                    }

                    if (result) {
                        console.log('[Save Success] Content saved successfully.');
                        // 可选：短暂显示保存成功状态 (变绿)
                        if (saveBtn) {
                            saveBtn.classList.add('save-success');
                            setTimeout(() => {
                               saveBtn.classList.remove('save-success');
                            }, 1500); // 1.5秒后移除绿色状态
                        }
                        // 确保字数统计在保存后更新（如果内容在此期间变化）
                        updateRightSidebarTitle(currentEditingBookTitle, novelContent.value);
                    } else {
                         console.error('[Save Failed] Failed to save content.');
                         if (saveBtn) {
                            // 可视化失败，例如短暂变红？或只留 log
                            saveBtn.textContent = '保存失败!';
                             setTimeout(() => {
                                  if (!saveBtn.disabled) saveBtn.textContent = '保存'; // 恢复文本
                             }, 2000);
                         }
                         // 可以添加更强的错误提示
                         // alert('自动保存失败，请检查网络或稍后手动保存。');
                    }
                } else {
                    console.log('[Save Skipped] No book selected or not editing a book.');
                }
            }

            // --- 生成按钮事件监听 --- 
             if (generateBtn) {
                 generateBtn.addEventListener('click', triggerGeneration); // Call the generation function on click
                 /* --- Original click listener code moved to triggerGeneration() --- */
                 /* generateBtn.addEventListener('click', async () => { ... }); */
             } else {
                 console.error("Generate button not found!");
             }
             
            // --- Add Undo Button Listener ---
            if (undoGenBtn) {
                 undoGenBtn.addEventListener('click', () => {
                     if (lastGeneratedRange) {
                         console.log('Undo clicked, removing range:', lastGeneratedRange);
                         const currentValue = novelContent.value;
                         const range = lastGeneratedRange;
                         
                         // Remove the text
                         novelContent.value = currentValue.slice(0, range.start) + currentValue.slice(range.end);
                         
                         // Move cursor back to the start of the removed range
                         novelContent.focus();
                         novelContent.setSelectionRange(range.start, range.start);
                         
                         // Reset state
                         lastGeneratedRange = null;
                         undoGenBtn.style.display = 'none';
                         
                         // Trigger input event to update counts etc.
                         novelContent.dispatchEvent(new Event('input', { bubbles: true }));
                         
                         // Optional: Trigger auto-save after undo
                         // if (debounceSaveSettings) debounceSaveSettings(); 
                     } else {
                         console.warn('Undo clicked but no valid range stored.');
                         undoGenBtn.style.display = 'none'; // Hide if somehow visible without range
                     }
                 });
            } else {
                console.error('Undo Generate button not found!');
            }

        });

        // 点击页面其他地方隐藏菜单 (不变)
        document.addEventListener('click', () => {
            hideContextMenu();
            hideCreateMenu();
        });

        // 右键菜单点击事件 (调用修改后的函数)
        contextMenu.addEventListener('click', (event) => {
            if (contextTarget && event.target.dataset.action) {
                const action = event.target.dataset.action;
                if (action === 'rename') {
                    startRename(contextTarget);
                } else if (action === 'delete') {
                    // contextTarget.item 包含 API 返回的数据
                        deleteItem(contextTarget.item);
                }
            }
            hideContextMenu();
        });

        // 创建按钮点击 (不变)
        createBtn.addEventListener('click', showCreateMenu);

        // 创建菜单点击 (调用修改后的函数)
        createMenu.addEventListener('click', (event) => {
             if (event.target.dataset.type) {
                 createNewItem(event.target.dataset.type);
             }
             hideCreateMenu();
        });

        // 删除按钮的拖放监听器 (handleDrop 已修改为调用 API)
        deleteBtn.addEventListener('dragenter', (event) => {
             event.preventDefault();
             currentDragTargetElement = deleteBtn;
         });
        deleteBtn.addEventListener('dragover', (event) => {
             event.preventDefault();
             event.dataTransfer.dropEffect = 'move';
             clearDropClasses(deleteBtn);
             deleteBtn.classList.add('drag-over-delete');
             insertPosition = 'delete';
             currentDragTargetElement = deleteBtn;
         });
        deleteBtn.addEventListener('dragleave', (event) => {
             deleteBtn.classList.remove('drag-over-delete');
             const relatedTarget = event.relatedTarget;
             if (!relatedTarget || !relatedTarget.closest('.file-item')) {
                  insertPosition = null;
                  currentDragTargetElement = null;
             }
         });
        deleteBtn.addEventListener('drop', (event) => {
            // handleDrop 现在会处理 delete position
            handleDrop(event, null, deleteBtn);
        });

        // Re-add the clearSettingDisplay function
        function clearSettingDisplay() {
             settingContent.innerHTML = `<p>点击左侧设定书查看详情</p>`;
             // Also clear any stored IDs related to the setting view
             delete settingContent.dataset.currentItemId;
             delete settingContent.dataset.currentItemType;
             delete settingContent.dataset.settingBookId; // Clear setting book ID if stored here
             // *** 修改点：重置标题和全局变量 ***
             currentEditingBookTitle = null;
             isWordCountLimitAlertShown = false; // Reset flag
             updateRightSidebarTitle('设定详情'); // Reset title
        }

        // --- 新增：更新右侧边栏标题的辅助函数 ---
        function updateRightSidebarTitle(title, content = null) {
            const maxChars = 25000; // 最大值仍然是 25000

            if (bookTitleTextSpan && wordCountBadgeSpan) {
                bookTitleTextSpan.textContent = title; // Set title text

                if (content !== null && title !== '设定详情') {
                     // 使用新的字符计数函数
                     const charCount = countCharacters(content);
                     // console.log('[updateRightSidebarTitle] Updating badge for:', title, 'Content Length:', content.length, 'Calculated Char Count:', charCount); // 更新日志标签
                     wordCountBadgeSpan.textContent = `(${charCount} / ${maxChars} 字)`; // 显示字符数
                     wordCountBadgeSpan.style.display = 'inline-block'; // Show badge

                    // 检查是否超限
                    const isOverLimit = charCount > maxChars;

                    if (isOverLimit) {
                        wordCountBadgeSpan.classList.add('limit-exceeded');
                        if (!isWordCountLimitAlertShown) {
                            alert(`字数（字符数）已超过 ${maxChars} 字上限！当前 ${charCount} 字。`); // 更新提醒信息
                            isWordCountLimitAlertShown = true;
                        }
                    } else {
                        wordCountBadgeSpan.classList.remove('limit-exceeded');
                        isWordCountLimitAlertShown = false;
                    }

                } else {
                    // console.log('[updateRightSidebarTitle] Hiding badge for:', title);
                    wordCountBadgeSpan.style.display = 'none';
                    wordCountBadgeSpan.classList.remove('limit-exceeded');
                    isWordCountLimitAlertShown = false;
                }
            } else {
                 console.error("Could not find title or badge span elements.");
                 rightSidebarTitle.textContent = title;
            }
        }

        // --- 占位：更新用户设置 API ---
        async function updateUserSettingAPI(settingKey, settingValue) {
            console.log(`Updating user setting via API: ${settingKey} = ${settingValue}`);
            return await fetchAPI('/api/user/settings', { // 实际的端点
                method: 'PUT',
                body: { [settingKey]: settingValue }
            });
        }

        // --- 新增：获取未关联书籍 API ---
        async function getUnassociatedBooksAPI() {
            return await fetchAPI('/api/books/unassociated');
        }


        // --- 字符统计函数 (原 countWords) ---
        // ... existing code ...

        // --- 事件处理函数 (需要大幅修改) ---

        // --- 新增：打开书籍并加载内容的函数 ---
        async function openBook(bookData) {
            console.log(`[Open Book] Opening book: ${bookData.name} (ID: ${bookData.id})`);

            // 1. 切换中央区域显示
            showEditorArea(); // 确保编辑区可见

            // 2. 清理右侧设定区 (除非稍后加载关联设定)
            clearSettingDisplay(); // 清除旧设定

            // 3. 获取书籍内容 (包含关联设定信息)
            novelContent.value = '加载中...'; // 显示加载提示
            novelContent.dataset.currentItemId = bookData.id;
            novelContent.dataset.currentItemType = 'book';
            currentEditingBookTitle = bookData.name; // 先设置标题
            isWordCountLimitAlertShown = false; // 重置提醒标记
            updateRightSidebarTitle(currentEditingBookTitle); // 显示标题，无字数

            const contentData = await getContentAPI(bookData.id);
            console.log("[Open Book] Received content data:", contentData);

            if (contentData) {
                // 更新编辑器内容
                novelContent.value = contentData.content || '';
                // 更新侧边栏标题和字数
                updateRightSidebarTitle(currentEditingBookTitle, contentData.content || '');

                // 检查并显示关联的设定书
                if (contentData.associatedSetting) {
                    console.log('[Open Book] Book has associated setting, displaying...', contentData.associatedSetting);
                    // 注意：displaySettingDetails 需要完整的 setting item 数据，
                    // 而 contentData.associatedSetting 现在只包含 id, name, type
                    // 我们需要再次获取完整的 setting details
                    const fullSettingData = await getContentAPI(contentData.associatedSetting.id);
                    if (fullSettingData) {
                        displaySettingDetails(fullSettingData);
                        settingContent.dataset.currentItemId = fullSettingData.id;
                        settingContent.dataset.currentItemType = 'setting';
                    } else {
                         console.error('[Open Book] Failed to fetch full details for associated setting.');
                         clearSettingDisplay(); // 获取失败则清空
                    }
                } else {
                    console.log('[Open Book] Book does not have an associated setting.');
                    clearSettingDisplay(); // 确认清空
                }
            } else {
                console.error('[Open Book] Failed to fetch content data.');
                novelContent.value = '加载内容失败。';
                delete novelContent.dataset.currentItemId;
                delete novelContent.dataset.currentItemType;
                updateRightSidebarTitle(bookData.name); // 保留标题，无字数
                currentEditingBookTitle = null;
                isWordCountLimitAlertShown = false;
                clearSettingDisplay();
            }
            console.log("[Open Book] Finished opening book.");
        }

        // --- 新增：渲染未关联书籍列表 --- 
        function renderUnassociatedBookList(books, settingBookId, containerElement) {
            containerElement.innerHTML = ''; // 清空旧内容
            
            const title = document.createElement('h4');
            const settingItem = fileList.querySelector(`.file-item[data-id="${settingBookId}"]`);
            const settingName = settingItem ? settingItem.querySelector('.item-name').textContent : '此设定书';
            title.textContent = `将《${settingName}》关联到哪本书籍？`;
            containerElement.appendChild(title);
            
            if (!books || books.length === 0) {
                containerElement.innerHTML += '<p style="color: #6c757d;">没有找到未关联任何设定书的书籍。</p>';
                return;
            }

            const ul = document.createElement('ul');
            ul.classList.add('unassociated-book-list');
            ul.dataset.settingBookId = settingBookId; // 将设定书 ID 存起来

            books.forEach(book => {
                const li = document.createElement('li');
                li.classList.add('unassociated-book-item');
                li.dataset.bookId = book.id; // 存储书籍 ID
                li.innerHTML = `
                    <i class="fas fa-book"></i>
                    <span>${book.name}</span>
                `;
                li.addEventListener('click', (event) => handleAssociateAndOpenBook(event, settingBookId));
                ul.appendChild(li);
            });
            containerElement.appendChild(ul);
        }

        // --- 新增：处理关联并打开书籍的点击事件 ---
        async function handleAssociateAndOpenBook(event, settingBookId) {
            const clickedLi = event.currentTarget;
            const bookId = clickedLi.dataset.bookId;
            const bookName = clickedLi.querySelector('span').textContent;

            console.log(`[Associate Click] Associating Setting ${settingBookId} with Book ${bookId} (${bookName})...`);

            // 禁用列表点击，防止重复操作
            clickedLi.closest('.unassociated-book-list').style.pointerEvents = 'none';
            clickedLi.style.backgroundColor = '#d1e7dd'; // 显示选中状态
            clickedLi.innerHTML += ' <i>关联中...</i>';

            const result = await associateSettingAPI(bookId, settingBookId);

            if (result && result.id == bookId) { // API 成功后返回更新后的 book 信息
                console.log('[Associate Click] Association successful.');
                // 关联成功后，直接调用 openBook 打开这本书
                // 需要构造 bookData 对象
                const bookData = { id: bookId, name: bookName, type: 'book' }; 
                await openBook(bookData);
            } else {
                 console.error('[Associate Click] Association failed.');
                 alert('关联失败，请重试。');
                 // 恢复列表
                 clickedLi.closest('.unassociated-book-list').style.pointerEvents = 'auto';
                 clickedLi.style.backgroundColor = '';
                 clickedLi.querySelector('i:last-child').remove();
            }
        }

        // --- 新增：控制中央区域显示的辅助函数 ---
        function showEditorArea() {
            centralDisplayArea.style.display = 'none';
            novelContent.style.display = 'block';
            promptBar.style.display = 'flex'; // prompt-bar 用的是 flex
            console.log('[Display Control] Showing Editor Area');
        }

        function showCentralDisplay() {
             centralDisplayArea.innerHTML = '<div><i>加载中...</i></div>'; // 清空并显示加载状态
             centralDisplayArea.style.display = 'block';
             novelContent.style.display = 'none';
             promptBar.style.display = 'none';
             console.log('[Display Control] Showing Central Display Area');
        }


        async function handleItemClick(event, itemData, itemElement) {
            event.stopPropagation();
            console.log('Clicked:', itemData.name, 'Type:', itemData.type);

            // --- 离开时自动保存逻辑 (保持不变) ---
            const previouslyEditingItemId = novelContent.dataset.currentItemId;
            const previouslyEditingItemType = novelContent.dataset.currentItemType;

            if (isAutoSaveOnNavigateEnabled &&
                previouslyEditingItemId && previouslyEditingItemType === 'book' &&
                previouslyEditingItemId !== String(itemData.id) // 确保不是点击当前正在编辑的书 (id可能是数字或字符串)
               ) {
                 console.log(`[AutoSave Navigate] Triggering save for book ${previouslyEditingItemId} before switching to ${itemData.name}`);
                 if (autoSaveTimer) {
                     clearTimeout(autoSaveTimer);
                     autoSaveTimer = null;
                     console.log('[AutoSave Navigate] Cleared pending input auto-save timer.');
                 }
                 await saveCurrentBookContent();
                 console.log(`[AutoSave Navigate] Save completed for ${previouslyEditingItemId}.`);
            }
            // --- 结束：离开时自动保存逻辑 ---

            // --- 清理和重置通用状态 ---
            currentEditingBookTitle = null;
            isWordCountLimitAlertShown = false; // 重置提醒标记
            // ** 在处理点击前，先确定是否需要显示编辑器 **
            // 默认显示编辑器，除非是未关联的设定书
            // showEditorArea(); // 移动到具体分支处理

            // --- 根据类型处理 --- 
            if (itemData.type === 'folder') {
                // --- 处理文件夹点击 (展开/折叠/加载子项) --- 
                showEditorArea(); // 点击文件夹时显示编辑器区域（但内容为空）
                novelContent.value = ''; // 清空编辑器
                delete novelContent.dataset.currentItemId;
                delete novelContent.dataset.currentItemType;
                clearSettingDisplay(); // 清空右侧设定区
                updateRightSidebarTitle('设定详情'); // 重置右侧标题

                const folderId = itemData.id;
                const isCollapsed = itemElement.classList.toggle('collapsed');
                const childrenUl = itemElement.querySelector('ul');

                await toggleFolderAPI(folderId, isCollapsed); // 更新后端折叠状态

                if (!isCollapsed && childrenUl && childrenUl.children.length === 0) {
                    console.log(`Fetching children for folder ${folderId}...`);
                    childrenUl.innerHTML = '<li><i>加载中...</i></li>';
                    const childrenData = await fetchItems(folderId);
                    if (childrenData) {
                        renderFileList(childrenData, childrenUl);
                    } else {
                        childrenUl.innerHTML = '<li><i>加载失败</i></li>';
                    }
                }
                if (childrenUl) {
                    childrenUl.style.display = isCollapsed ? 'none' : 'block';
                }

            } else if (itemData.type === 'book') {
                // --- 处理书籍点击 (调用新函数打开) --- 
                await openBook(itemData); // 直接使用 itemData

            } else if (itemData.type === 'setting') {
                // --- 处理设定书点击 --- 
                console.log(`[Setting Click] Handling click for setting: ${itemData.name}`);
                novelContent.value = ''; // 清空编辑器
                delete novelContent.dataset.currentItemId;
                delete novelContent.dataset.currentItemType;
                clearSettingDisplay(); // 清空右侧设定区
                updateRightSidebarTitle('设定详情'); // 重置右侧标题

                // 获取设定书内容，检查是否有 'associatedBookInfo'
                const settingDetails = await getContentAPI(itemData.id);

                if (settingDetails && settingDetails.associatedBookInfo) {
                    // --- 情况1：设定书已关联 --- 
                    console.log(`[Setting Click] Setting ${itemData.name} is associated with Book ID: ${settingDetails.associatedBookInfo.id}`);
                    // 直接打开关联的书籍
                    await openBook(settingDetails.associatedBookInfo); // 使用关联的书籍信息
                } else if (settingDetails) {
                    // --- 情况2：设定书未关联 --- 
                    console.log(`[Setting Click] Setting ${itemData.name} is not associated. Fetching unassociated books...`);
                    showCentralDisplay(); // 显示中央列表区域
                    const unassociatedBooks = await getUnassociatedBooksAPI();
                    if (unassociatedBooks) {
                        renderUnassociatedBookList(unassociatedBooks, itemData.id, centralDisplayArea);
                    } else {
                        centralDisplayArea.innerHTML = '<h4>关联书籍</h4><p>加载未关联书籍列表失败。</p>';
                    }
                    // 同时，在右侧显示设定书本身的编辑界面 (如果需要的话)
                    // displaySettingDetails(settingDetails);
                    // settingContent.dataset.currentItemId = itemData.id;
                    // settingContent.dataset.currentItemType = 'setting';
                    // 考虑到主要流程是关联，暂时不在右侧显示设定编辑界面
                    clearSettingDisplay(); // 保持右侧清空或显示提示
                    updateRightSidebarTitle(`关联《${itemData.name}》`); // 更新右侧标题提示

                } else {
                    // 获取设定详情失败
                    console.error(`[Setting Click] Failed to get details for setting ${itemData.name}.`);
                    showEditorArea(); // 显示回编辑器（空的）
                    alert('加载设定书信息失败。');
                }
            }
        }

        // function toggleFolder(folderItem) { ... } // 被 handleItemClick 替代

        // --- 新增：获取并填充模板下拉框 ---
        async function populateTemplateSelector() {
            try {
                const response = await fetch('/api/prompt-templates');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const templates = await response.json();

                templateSelect.innerHTML = '<option value="">-- 选择模板 --</option>'; // 清空并添加默认选项
                templates.forEach(template => {
                    const option = document.createElement('option');
                    option.value = template.id;
                    option.textContent = template.name;
                     // 可选：如果模板是默认模板，默认选中它
                    if (template.is_default) {
                         option.selected = true;
                    }
                    templateSelect.appendChild(option);
                });
            } catch (error) {
                console.error('获取模板列表失败:', error);
                templateSelect.innerHTML = '<option value="">加载模板失败</option>';
            }
        }

        // --- 新增：获取并填充 AI 服务下拉框 --- 
        async function populateAiServiceSelector() {
             try {
                 const response = await fetch('/api/ai-services/available');
                 if (!response.ok) {
                     throw new Error(`HTTP error! status: ${response.status}`);
                 }
                 const services = await response.json();

                 aiServiceSelect.innerHTML = '<option value="">-- 使用默认 --</option>'; // Default option
                 services.forEach(service => {
                     const option = document.createElement('option');
                     option.value = service.id;
                     option.textContent = service.name; // Name already includes type (系统/我的)
                     aiServiceSelect.appendChild(option);
                 });
             } catch (error) {
                 console.error('获取可用 AI 服务列表失败:', error);
                 aiServiceSelect.innerHTML = '<option value="">加载服务失败</option>';
             }
         }

        // --- Debounce Utility --- 
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        // --- Settings Auto-Save Logic ---
        const settingContentElement = document.getElementById('setting-content');
        let debounceSaveSettings = null; // Will hold the debounced function

        async function autoSaveSettings() {
            const settingList = settingContentElement.querySelector('.setting-list');
            const settingBookId = settingList ? settingList.dataset.settingBookId : null;
            const saveButton = document.getElementById('save-settings-btn'); // Get the save button

            if (settingList && settingBookId) {
                 console.log(`[AutoSave Settings] Triggered for setting book ${settingBookId}.`);
                 const updatedSettings = [];
                 const settingItems = settingList.querySelectorAll('.setting-item');
                 settingItems.forEach(item => {
                     const textarea = item.querySelector('.setting-text-input');
                     const checkbox = item.querySelector('.setting-enabled-toggle');
                     if (textarea && checkbox) {
                         updatedSettings.push({
                             text: textarea.value,
                             enabled: checkbox.checked
                         });
                     }
                 });
                 
                 // Provide subtle feedback (optional)
                 if(saveButton && !saveButton.disabled) {
                     saveButton.textContent = '自动保存中...';
                 }

                 const result = await updateContentAPI(settingBookId, 'setting', updatedSettings);
                 
                 if(saveButton && !saveButton.disabled) {
                    if (result) {
                         console.log('[AutoSave Settings] Success.');
                         saveButton.textContent = '已自动保存 ✓';
                         setTimeout(() => { 
                              if (!saveButton.disabled) saveButton.textContent = '保存设定'; 
                         }, 1500); // Show checkmark briefly
                     } else {
                         console.error('[AutoSave Settings] Failed.');
                         saveButton.textContent = '自动保存失败!';
                         setTimeout(() => { 
                              if (!saveButton.disabled) saveButton.textContent = '保存设定'; 
                         }, 2000); // Show error briefly
                     }
                 }
            } else {
                 console.log('[AutoSave Settings] Skipped: No active setting book ID found.');
            }
        }
        
        // Create the debounced version (e.g., save 2 seconds after last change/blur)
        debounceSaveSettings = debounce(autoSaveSettings, 2000);

        // Add event listener for changes/blur within the settings panel
        if (settingContentElement) {
             settingContentElement.addEventListener('input', (event) => {
                 // Trigger on text changes in textareas
                 if (event.target.classList.contains('setting-text-input')) {
                     if(debounceSaveSettings) debounceSaveSettings();
                 }
             });
             settingContentElement.addEventListener('change', (event) => {
                 // Trigger on checkbox changes
                 if (event.target.classList.contains('setting-enabled-toggle')) {
                     if(debounceSaveSettings) debounceSaveSettings();
                 }
             });
             // Optional: Trigger on blur as well, though input/change might be sufficient
             settingContentElement.addEventListener('blur', (event) => {
                  if (event.target.classList.contains('setting-text-input') || event.target.classList.contains('setting-enabled-toggle')) {
                      if(debounceSaveSettings) debounceSaveSettings();
                  }
             }, true); // Use capture phase for blur if needed
             
             // --- Add Listener for Setting Textarea Enter Key ---
             settingContentElement.addEventListener('keydown', (event) => {
                 if (event.target.classList.contains('setting-text-input')) {
                     if (event.key === 'Enter' && !event.shiftKey) {
                         event.preventDefault(); // Prevent newline
                         console.log('Enter pressed in setting textarea, saving and moving focus...');
                         
                         // 1. Trigger immediate save
                         autoSaveSettings(); // Call the existing save function directly

                         // 2. Find next setting item and focus its textarea
                         const currentLi = event.target.closest('.setting-item');
                         if (currentLi) {
                             let nextLi = currentLi.nextElementSibling;
                             // Skip non-item elements if any (e.g., text nodes)
                             while (nextLi && !nextLi.classList.contains('setting-item')) {
                                 nextLi = nextLi.nextElementSibling;
                             }

                             if (nextLi) {
                                 const nextTextarea = nextLi.querySelector('.setting-text-input');
                                 if (nextTextarea) {
                                     nextTextarea.focus();
                                     // Move cursor to the end
                                     const len = nextTextarea.value.length;
                                     nextTextarea.setSelectionRange(len, len);
                                 }
                             }
                         }
                     }
                     // Shift + Enter will insert newline by default
                 }
             });
        }
        
        // Modify Manual Save Button listener
        settingContent.addEventListener('click', async (event) => {
            const target = event.target;
            // ... (existing add/delete button logic) ...

            // Handle Save Settings Button
            if (target.id === 'save-settings-btn') {
                 // Clear any pending debounced save immediately
                 if (debounceSaveSettings && typeof clearTimeout === 'function') {
                     // Need access to the timeout variable inside debounce, which is tricky.
                     // Simplest alternative: just call the save function directly.
                     // Or, restructure debounce to allow cancelling.
                     // Let's just save immediately.
                     console.log('[Manual Save] Clearing pending auto-save and saving now.');
                 } 

                const settingList = settingContent.querySelector('.setting-list');
                const settingBookId = settingList ? settingList.dataset.settingBookId : null;
                const saveButton = document.getElementById('save-settings-btn'); // Get the save button

                if (settingList && settingBookId) {
                    const updatedSettings = [];
                    const settingItems = settingList.querySelectorAll('.setting-item');
                    settingItems.forEach(item => {
                        const textarea = item.querySelector('.setting-text-input');
                        const checkbox = item.querySelector('.setting-enabled-toggle');
                        if (textarea && checkbox) {
                            updatedSettings.push({
                                text: textarea.value,
                                enabled: checkbox.checked
                            });
                        }
                    });

                    console.log(`Saving settings for book ${settingBookId}:`, updatedSettings);
                    target.textContent = '保存中...';
                    target.disabled = true;

                    const result = await updateContentAPI(settingBookId, 'setting', updatedSettings);
                    
                    target.textContent = '保存设定';
                    target.disabled = false;

                    if (result) {
                         console.log('Settings saved successfully.');
                         target.textContent = '已保存 ✓';
                         setTimeout(() => { target.textContent = '保存设定'; }, 2000);
                     } else {
                         console.error('Failed to save settings.');
                         // Error already alerted by fetchAPI
                     }
                } else {
                     console.error('Could not find setting list or book ID for saving.');
                     alert('无法保存设定，缺少必要信息。');
                }
            }
        });

=======
            if (cancelGenerationBtn) cancelGenerationBtn.addEventListener('click', () => { console.log('Cancel button clicked.'); showEditorArea(); });
            if (novelContent) novelContent.addEventListener('input', () => { if (currentEditingBookTitle && novelContent.dataset.currentItemType === 'book') updateRightSidebarTitle(currentEditingBookTitle, novelContent.value); });
            if (promptInput) promptInput.addEventListener('keydown', (event) => { if (event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); if (generateBtn && !generateBtn.disabled) triggerGeneration(); } });
            if (contextMenu) contextMenu.addEventListener('click', (event) => { if (contextTarget && event.target.dataset.action) { const action = event.target.dataset.action; if (action === 'rename') startRename(contextTarget); else if (action === 'delete') deleteItem(contextTarget.item); } hideContextMenu(); });
            if (createBtn) createBtn.addEventListener('click', showCreateMenu);
            if (createMenu) createMenu.addEventListener('click', (event) => { if (event.target.dataset.type) createNewItem(event.target.dataset.type); hideCreateMenu(); });
            if (deleteBtn) { /* deleteBtn drag listeners */ 
                 deleteBtn.addEventListener('dragenter', (event) => { event.preventDefault(); currentDragTargetElement = deleteBtn; });
                 deleteBtn.addEventListener('dragover', (event) => { event.preventDefault(); event.dataTransfer.dropEffect = 'move'; clearDropClasses(deleteBtn); deleteBtn.classList.add('drag-over-delete'); insertPosition = 'delete'; currentDragTargetElement = deleteBtn; });
                 deleteBtn.addEventListener('dragleave', (event) => { deleteBtn.classList.remove('drag-over-delete'); const related = event.relatedTarget; if (!related || !related.closest('.file-item')) { insertPosition = null; currentDragTargetElement = null; } });
                 deleteBtn.addEventListener('drop', (event) => handleDrop(event, null, deleteBtn));
            }
            if (settingContent) { /* settingContent listeners */ 
                debounceSaveSettings = debounce(autoSaveSettings, 2000);
                 settingContent.addEventListener('input', (event) => { if (event.target.classList.contains('setting-text-input')) debounceSaveSettings(); });
                 settingContent.addEventListener('change', (event) => { if (event.target.classList.contains('setting-enabled-toggle')) debounceSaveSettings(); });
                 settingContent.addEventListener('blur', (event) => { if (event.target.classList.contains('setting-text-input') || event.target.classList.contains('setting-enabled-toggle')) debounceSaveSettings(); }, true);
                 settingContent.addEventListener('keydown', (event) => { /* Enter key logic for settings */ if (event.target.classList.contains('setting-text-input') && event.key === 'Enter' && !event.shiftKey) { event.preventDefault(); autoSaveSettings(); const currentLi = event.target.closest('.setting-item'); let nextLi = currentLi?.nextElementSibling; while (nextLi && !nextLi.classList.contains('setting-item')) nextLi = nextLi.nextElementSibling; if (nextLi) nextLi.querySelector('.setting-text-input')?.focus(); } });
                 settingContent.addEventListener('click', async (event) => { /* Add/Delete/Save Setting buttons logic */ const target = event.target; if (target.id === 'add-setting-btn') { const list = settingContent.querySelector('.setting-list'); if(list) { const item = createSettingItemElement({text:'', enabled:true}, list.children.length); list.appendChild(item); item.querySelector('textarea')?.focus();} } else if (target.classList.contains('delete-setting-btn')) { if(confirm('确定删除？')) target.closest('.setting-item')?.remove(); } else if (target.id === 'save-settings-btn') { if(debounceSaveSettings) { /* Clear pending debounce? */ } const list = settingContent.querySelector('.setting-list'); const bookId = list?.dataset.settingBookId; if(list && bookId){ const settings = []; list.querySelectorAll('.setting-item').forEach(i=>{const t=i.querySelector('.setting-text-input');const c=i.querySelector('.setting-enabled-toggle');if(t&&c)settings.push({text:t.value,enabled:c.checked});}); target.textContent='保存中...';target.disabled=true; const res=await updateContentAPI(bookId,'setting',settings); target.disabled=false; if(res){target.textContent='已保存 ✓';setTimeout(()=>target.textContent='保存设定',2000);} else {target.textContent='保存失败!';setTimeout(()=>target.textContent='保存设定',2000);}} else {alert('无法保存');}}});
            }
            
            // Global listeners
             document.addEventListener('click', () => { hideContextMenu(); hideCreateMenu(); });
             document.addEventListener('dragend', (event) => { console.log("Drag End"); cleanupDragState(); });
        });

        // ... (Rest of the script: Function Definitions, Global Listeners) ...
>>>>>>> local
    </script>
</body>
</html> 