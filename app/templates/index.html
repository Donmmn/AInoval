<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>主界面 - 小说编辑器</title>
    <link rel="stylesheet" href="/static/style.css">
    <!-- 引入 Font Awesome 图标库 (示例) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">
    <!-- 移除 TinyMCE 编辑器脚本 -->
    <!-- <script src="https://cdn.tiny.cloud/1/no-api-key/tinymce/6/tinymce.min.js" referrerpolicy="origin"></script> -->
    <!-- 新增：引入 Quill 编辑器样式和脚本 -->
    <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">
    <script src="https://cdn.quilljs.com/1.3.6/quill.js"></script>
    <!-- 新增：引入 marked.js 用于 Markdown 解析 -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <style>
        .editor-container {
            margin: 0;
            width: 100%;
            padding: 0; 
            display: flex;
            flex-direction: column;
            position: relative;
            flex: 1;
            overflow: hidden;
        }
        .novel-editor-area {
            flex: 1; 
            display: flex; 
            flex-direction: column;
            position: relative; 
            overflow: hidden; 
            padding: 0; 
        }
        /* 移除针对 #novel-content textarea 的样式 */
        /* .novel-editor { ... } */

        /* Quill 容器样式 */
        #quill-editor-wrapper { /* 新增一个包裹层，用于flex布局 */
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* 防止内容溢出影响布局 */
            min-height: 150px; /* 保持最小高度 */
            border: 1px solid #ccc; /* 可以给编辑器一个边框 */
            border-radius: 4px; /* 可选圆角 */
            background-color: #fafbfc; /* 背景色 */
        }
        #quill-editor-wrapper .ql-toolbar {
            background: #f9f9f9; /* 工具栏背景 */
            border-bottom: 1px solid #ccc;
            border-top-left-radius: 4px; /* 可选圆角 */
            border-top-right-radius: 4px;
        }
        #quill-editor-wrapper .ql-container {
            flex: 1; /* 让容器填充剩余空间 */
            overflow-y: auto; /* 允许内容滚动 */
            border: none; /* Quill 容器通常不需要边框 */
            font-size: 18px; /* 编辑区字体大小 */
            font-family: 'Microsoft YaHei', Arial, sans-serif; /* 编辑区字体 */
            display: flex; /* 新增 */
            flex-direction: column; /* 新增 */
        }
        #quill-editor-wrapper .ql-editor {
            flex: 1; /* 编辑器本身填充容器 */
            padding: 12px 15px; /* 编辑区内边距 */
            padding-bottom: calc(50vh + 100px); /* 为下方的 prompt-bar 留出空间 */
            box-sizing: border-box;
            line-height: 1.6; /* 行高 */
            overflow-y: auto; /* 确保编辑器内部可滚动 */
            background-color: #fafbfc; /* 确保编辑区背景色 */
            height: auto; /* Quill 需要这个来正确计算高度 */
        }
        /* Quill 编辑器内容区域的 placeholder 样式 */
        .ql-editor.ql-blank::before {
            color: rgba(0,0,0,0.6);
            content: attr(data-placeholder);
            font-style: italic;
            position: absolute; /* 修改 */
            left: 15px; /* 与 padding 匹配 */
            top: 12px; /* 与 padding 匹配 */
            pointer-events: none;
        }


        .prompt-bar {
            position: absolute;
            bottom: 15px; 
            left: 5%; 
            right: 5%;
            width: 90%; 
            z-index: 10; 
            box-sizing: border-box; 
            margin: 0 auto; 
            background: #ffffff; 
            border-radius: 8px; 
            box-shadow: 0 2px 8px rgba(0,0,0,0.15); 
            padding: 15px 20px; 
            display: flex; 
        }
        .prompt-row {
            display: flex;
            align-items: stretch; 
            gap: 10px; 
            width: 100%;
        }
        textarea.prompt-input {
            flex: 1; 
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 15px;
            padding: 8px 10px;
            overflow-y: auto; 
            font-family: inherit;
            line-height: 1.4;
            min-height: 70px; 
        }
        .prompt-actions {
            display: flex; 
            flex-direction: column;
            gap: 4px;
            align-items: stretch; 
            flex-shrink: 0; 
            width: 80px; 
        }
        .prompt-actions button {
            padding: 6px 18px;
            font-size: 15px;
            width: 100%; 
            text-align: center;
            box-sizing: border-box;
            border: 1px solid #ccc; 
            background-color: #f0f0f0; 
            color: #333; 
            cursor: pointer;
            transition: background-color 0.3s, color 0.3s, border-color 0.3s; 
        }
        .prompt-actions button:hover {
             background-color: #e0e0e0; 
        }
        .prompt-actions button:disabled {
            background-color: #ddd; 
            color: #999; 
            cursor: not-allowed;
        }

        .prompt-actions button.save-success {
            background-color: #d1e7dd; 
            border-color: #a3cfbb; 
            color: #0f5132; 
        }

        body {
            background: #f7f7f7;
            overflow-x: hidden; 
        }
        .main-flex {
            display: flex;
            width: 100vw;
            min-height: calc(100vh - 60px); 
        }

        /* 左侧边栏 */
        .left-sidebar {
            width: 15vw;
            min-width: 200px; 
            max-width: 300px; 
            background: #e9eef2;
            border-right: 1px solid #d3d9df;
            padding: 15px;
            box-sizing: border-box;
            display: flex;
            flex-direction: column;
            overflow-y: auto; 
        }
        .sidebar-actions {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            gap: 10px;
        }
        .sidebar-btn {
            flex: 1; 
            background: #888;
            color: #fff;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            padding: 8px 10px;
            font-size: 14px;
            cursor: pointer;
            transition: background 0.2s;
            text-align: center;
        }
        .sidebar-btn.delete-btn {
            background: #c77; 
        }
        .sidebar-btn:hover {
            background: #222;
        }
        .sidebar-btn.delete-btn:hover {
            background: #a55;
        }

        /* 文件列表 */
        .file-list {
            list-style: none;
            padding: 0;
            margin: 0;
            flex-grow: 1; 
        }
        .file-item {
            padding: 6px 2px 6px 5px; 
            margin-bottom: 3px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 15px;
            user-select: none;
            position: relative;
            background-color: transparent; 
        }
        .file-item:hover {
            background-color: #dce4eb;
        }
        .file-item i { 
            margin-right: 8px;
            color: #555;
            width: 16px; 
            text-align: center;
            vertical-align: middle;
        }
        .file-item .folder-toggle { 
             transition: transform 0.2s ease-in-out;
             vertical-align: middle;
        }
        .file-item.collapsed .folder-toggle {
             transform: rotate(-90deg);
        }
        .file-item .item-name {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: inline-block;
            vertical-align: middle;
        }
        .file-item input.rename-input { 
            border: 1px solid #999;
            padding: 2px 4px;
            font-size: 15px;
            outline: none;
            width: calc(100% - 50px); 
            display: inline-block;
            vertical-align: middle;
        }
        .file-item ul { 
            list-style: none;
            padding-left: 25px; 
            margin-top: 5px;
            display: block;
            width: 100%;
            box-sizing: border-box;
        }
        .file-item.collapsed ul {
            display: none;
        }

        /* 中间编辑区容器 */
        .editor-outer {
            flex: 1;
            display: flex;
            padding: 0;
            box-sizing: border-box;
            overflow: hidden;
            height: calc(100vh - 60px);
            max-height: calc(100vh - 60px);
        }
        textarea.prompt-input {
            flex: 1;
            border-radius: 6px;
            border: 1px solid #ccc;
            font-size: 15px;
            padding: 8px 10px;
            overflow-y: auto; 
            font-family: inherit;
            line-height: 1.4;
            align-self: stretch; 
            resize: none; 
        }
        .word-count-input {
             width: 80px;
             font-size: 15px;
             padding: 8px 10px;
        }
        .word-count-label {
             margin-right: 4px;
        }
        .prompt-actions {
             display: flex;
             flex-direction: column;
             gap: 4px;
             align-items: flex-start;
        }
         .prompt-actions button {
            padding: 6px 18px;
            font-size: 15px;
        }

        /* 右侧边栏 */
        .right-sidebar {
            width: 20vw; 
            min-width: 250px;
            max-width: 350px;
            background: #f0f3f6;
            border-left: 1px solid #d3d9df;
            padding: 20px;
            box-sizing: border-box;
            overflow-y: auto;
        }
        .right-sidebar h3 {
            margin-top: 0;
            color: #444;
            border-bottom: 1px solid #ccc;
            padding-bottom: 10px;
        }
        #setting-content ul {
             list-style: disc;
             padding-left: 20px;
        }
         #setting-content li {
             margin-bottom: 8px;
             background: #fff;
             padding: 5px 8px;
             border-radius: 4px;
             box-shadow: 0 1px 2px rgba(0,0,0,0.05);
         }

        /* 简单的右键菜单样式 */
        .context-menu {
            position: absolute;
            background: #fff;
            border: 1px solid #ccc;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            padding: 5px 0;
            border-radius: 4px;
            z-index: 1000;
            display: none; 
        }
        .context-menu div {
            padding: 8px 15px;
            cursor: pointer;
            font-size: 14px;
        }
        .context-menu div:hover {
            background: #eee;
        }

         /* 创建菜单 */
         #create-menu {
             position: absolute;
             background: #fff;
             border: 1px solid #ccc;
             box-shadow: 0 2px 5px rgba(0,0,0,0.1);
             padding: 5px 0;
             border-radius: 4px;
             z-index: 1000;
             display: none;
         }
         #create-menu div {
             padding: 8px 15px;
             cursor: pointer;
             font-size: 14px;
         }
         #create-menu div:hover {
             background: #eee;
         }

        /* 拖放视觉反馈样式 */
        .file-item.drag-over-folder { 
            background-color: #cce5ff !important; 
            outline: 1px dashed #007bff;
        }

        .file-item.drag-over-insert-before,
        .file-item.drag-over-insert-after {
             position: relative; 
        }

        .file-item.drag-over-insert-before::before,
        .file-item.drag-over-insert-after::after { 
            content: '';
            position: absolute;
            left: 0;
            right: 0;
            height: 2px;
            background-color: #007bff; 
            z-index: 1;
        }
        .file-item.drag-over-insert-before::before {
            top: -1px; 
        }
        .file-item.drag-over-insert-after::after {
            bottom: -1px; 
        }

        #delete-btn.drag-over-delete { 
            background-color: #f8d7da !important; 
            border: 1px dashed #dc3545;
            outline: none; 
        }

        .file-item.dragging { 
            outline: 2px dashed #ff8c00; 
            background-color: #fff8dc; 
        }

        .file-item.drag-over-associate { 
            background-color: #d1e7dd !important; 
            outline: 1px dashed #198754;
        }

        /* Right Sidebar Setting Editor Styles */
        #setting-content {
            position: relative; 
        }
        .setting-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
        }
        .setting-item {
            display: flex;
            align-items: flex-start; 
            gap: 8px;
            margin-bottom: 10px;
            padding: 8px 8px 8px 4px; 
            background-color: #fff;
            border-radius: 4px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .setting-item-controls {
            display: flex;
            align-items: center; 
            gap: 5px;
        }
        .setting-item input[type=\"checkbox\"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
            margin-top: 4px; 
        }
        .setting-item textarea {
            flex: 1; 
            min-height: 40px; 
            height: auto; 
            resize: vertical; 
            max-height: 120px; 
            overflow-y: auto;
            border: 1px solid #ccc;
            border-radius: 4px;
            padding: 6px 8px;
            font-size: 14px;
            line-height: 1.4;
            box-sizing: border-box;
        }
        .setting-item .delete-setting-btn {
            background: #f8d7da;
            color: #842029;
            border: 1px solid #f5c2c7;
            border-radius: 50%; 
            width: 22px;
            height: 22px;
            line-height: 20px; 
            text-align: center;
            cursor: pointer;
            font-weight: bold;
            padding: 0;
            margin-top: 2px; 
            flex-shrink: 0; 
        }
        .setting-item .delete-setting-btn:hover {
            background: #e5a4aa;
        }

        .setting-header {
            display: flex;
            justify-content: space-between; 
            align-items: center;
            margin-bottom: 10px; 
            border-bottom: 1px solid #ccc;
            padding-bottom: 10px;
        }
        .setting-header h3 {
            margin: 0; 
            color: #444;
            flex-grow: 1; 
            border-bottom: none; 
            padding-bottom: 0;
        }
        .setting-actions {
            display: flex;
            gap: 8px; 
            flex-shrink: 0; 
        }
        .setting-actions button {
            padding: 5px 12px; 
            border-radius: 5px; 
            cursor: pointer;
            font-size: 13px; 
            border: 1px solid transparent; 
            line-height: normal; 
            height: auto; 
            width: auto; 
            text-align: center;
        }
        #add-setting-btn {
             background-color: #cfe2ff;
             border-color: #b6d4fe;
             color: #084298;
             font-size: 16px; 
        }
        #save-settings-btn {
             background-color: #d1e7dd;
             border-color: #a3cfbb;
             color: #0f5132;
        }
        
        .setting-item {
            display: flex;
            align-items: flex-start; 
            gap: 8px;
            margin-bottom: 10px;
            padding: 8px 8px 8px 4px; 
            background-color: #fff;
            border-radius: 4px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            width: 100%; 
            box-sizing: border-box;
        }

        #right-sidebar-title {
            display: flex;
            justify-content: space-between; 
            align-items: center; 
            width: 100%;
            box-sizing: border-box; 
        }

        .book-title-text {
            flex-grow: 1;
            min-width: 0;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-right: 10px; 
             font-size: inherit;
             font-weight: inherit;
             color: inherit;
             margin-bottom: 0; 
             padding-bottom: 0; 
             border-bottom: none; 

        }

        .word-count-badge {
            background-color: #e9ecef; 
            color: #495057; 
            padding: 3px 8px; 
            border-radius: 10px; 
            font-size: 0.8em; 
            font-weight: normal; 
            white-space: nowrap; 
            flex-shrink: 0; 
            transition: background-color 0.3s, color 0.3s; 
        }

        .word-count-badge.limit-exceeded {
            background-color: #f8d7da; 
            color: #842029; 
            font-weight: bold;
        }

         .right-sidebar h3 {
             margin-bottom: 10px; 
         }

         .setting-header {
         }

         /* --- 顶部栏样式调整 --- */
        .top-bar {
            display: flex; 
            justify-content: space-between; 
            align-items: center; 
            padding: 0 20px; 
            gap: 15px; 
        }

        .left-controls {
            display: flex;
            align-items: center;
            gap: 8px; 
        }

        .auto-save-label {
            color: #eee; 
            font-size: 14px;
            user-select: none; 
        }

        /* 简单的切换开关样式 */
        .toggle-switch {
            appearance: none;
            -webkit-appearance: none;
            position: relative;
            width: 40px; 
            height: 22px; 
            border-radius: 11px; 
            background-color: #aaa; 
            cursor: pointer;
            transition: background-color 0.3s;
            vertical-align: middle; 
        }

        .toggle-switch::before {
            content: '';
            position: absolute;
            top: 2px; 
            left: 2px; 
            width: 18px; 
            height: 18px; 
            border-radius: 50%; 
            background-color: white; 
            transition: transform 0.3s;
        }

        .toggle-switch:checked {
            background-color: #4CAF50; 
        }

        .toggle-switch:checked::before {
            transform: translateX(18px); 
        }

        .right-buttons {
            display: flex;
            gap: 15px; 
        }

        /* --- 中间显示区域样式 (用于显示未关联书籍列表) --- */
        #central-display-area {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
            background-color: #f0f3f6; 
        }
        #central-display-area h4 { 
            margin-top: 0;
            margin-bottom: 15px;
            color: #555;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }
        .unassociated-book-list {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .unassociated-book-item {
            padding: 10px 15px;
            margin-bottom: 8px;
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s, border-color 0.2s;
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 15px;
        }
        .unassociated-book-item:hover {
            background-color: #e9eef2;
            border-color: #cdd7e0;
        }
        .unassociated-book-item i {
            color: #666;
            width: 16px; 
            text-align: center;
        }

        /* 新增：点数余额样式 */
        .points-balance {
            color: #ffdd57; 
            font-size: 14px;
            margin-right: 10px; 
            font-weight: bold;
        }
        .points-balance .fas { 
            margin-right: 4px;
            font-size: 13px;
        }

        /* 新增：提示词栏选项样式 */
        .prompt-bar {
            padding: 10px 15px; 
        }
        .prompt-row {
            align-items: flex-start; 
            gap: 15px; 
        }
        .prompt-options {
            display: flex;
            flex-direction: column; 
            gap: 8px; 
            flex-shrink: 0; 
            width: 180px; 
        }
        .prompt-options div {
            display: flex;
            align-items: center; 
            gap: 5px; 
        }
        .prompt-options label {
            width: 40px; 
            text-align: right;
            font-size: 14px;
            color: #333;
            flex-shrink: 0;
        }
        .prompt-options select,
        .prompt-options input[type="number"],
        .prompt-options input[type="text"] {
            flex-grow: 1; 
            padding: 6px 8px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            min-width: 0; 
        }

        textarea.prompt-input {
            min-height: 80px; 
        }
        .prompt-actions {
             width: 70px; 
        }

        /* --- Styles for AI Generated Content --- */
        /* These might not be needed if Quill handles styling */
        .ai-generated {
            background-color: #e0f7ff; 
            padding: 1px 2px; 
            border-radius: 3px;
            position: relative; 
        }
        .delete-gen-btn {
            background: #ff4d4d;
            color: white;
            border: none;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            line-height: 15px; 
            text-align: center;
            font-size: 10px;
            font-weight: bold;
            cursor: pointer;
            padding: 0;
            margin-left: 5px; 
            vertical-align: middle; 
            opacity: 0.7;
            transition: opacity 0.2s;
        }
        .delete-gen-btn:hover {
            opacity: 1;
        }
        /* --- End AI Generated Styles --- */

    </style>
</head>
<body>
    <div class="top-bar">
        <div class="left-controls"> <!-- 新增容器 -->
            <label for="auto-save-toggle" class="auto-save-label">离开时自动保存: </label>
            {# 根据后端传递的值决定是否默认选中，并将值存入 data 属性 #}
            <input type="checkbox" id="auto-save-toggle"
                   class="toggle-switch"
                   data-initial-state="{{ user_auto_save_setting | tojson }}"
                   {% if user_auto_save_setting %}checked{% endif %}>
        </div>
        <div class="right-buttons">
            {% if current_user.is_authenticated and current_user.is_admin %}
            <a href="{{ url_for('user.manage') }}" class="top-btn">用户管理</a>
            {% endif %}
            {# 新增：显示点数余额 (仅对非管理员显示) #}
            {% if not current_user.is_admin %}
            <span class="points-balance" id="user-points-display">
                <i class="fas fa-coins"></i> {{ user_points }}
            </span>
            {% endif %}
            <a href="{{ url_for('ai_service.manage') }}" class="top-btn">AI服务管理</a>
            <a href="{{ url_for('main.logout') }}" class="top-btn">退出登录</a>
        </div>
    </div>

    <div class="main-flex">
        <!-- 左侧文件列表 -->
        <div class="left-sidebar">
            <div class="sidebar-actions">
                <button id="create-btn" class="sidebar-btn">创建</button>
                <button id="delete-btn" class="sidebar-btn delete-btn">删除区域</button>
            </div>
            <ul id="file-list" class="file-list">
                <!-- 文件项将由 JS 动态生成 -->
            </ul>
        </div>

        <!-- 中间编辑区 -->
        <div class="editor-outer">
            <div class="editor-container">
                <div class="novel-editor-area">
                    {# 新增：用于显示非编辑内容的容器 #}
                    <div id="central-display-area" style="display: none;">
                        <!-- 内容将由 JS 动态生成 -->
                    </div>
                    {# Quill 编辑器的容器 #}
                    <div id="quill-editor-wrapper"> {# 新增包裹层 #}
                        <div id="novel-content"></div> {# Quill 将作用于此 div #}
                    </div>
                    <div class="prompt-bar">
                        <div class="prompt-row">
                            <div class="prompt-options">
                                <div>
                                    <label for="template-select">模板:</label>
                                    <select id="template-select" name="template_id">
                                        <option value="">-- 选择模板 --</option>
                                        <!-- 模板选项将由 JS 填充 -->
                                    </select>
                                </div>
                                <div>
                                    <label for="ai-service-select">服务:</label>
                                    <select id="ai-service-select" name="ai_service_config_id">
                                        <option value="">-- 使用默认 --</option>
                                        <!-- AI 服务选项将由 JS 填充 -->
                                    </select>
                                </div>
                                <div>
                                    <label for="word-count-input">字数:</label>
                                    <input type="number" id="word-count-input" value="500" min="10" max="4000" step="10">
                                </div>
                                <div>
                                    <label for="style-input">风格:</label>
                                    <input type="text" id="style-input" placeholder="例如：奇幻、科幻...">
                                </div>
                            </div>
                            <textarea class="prompt-input" placeholder="输入AI提示词..." rows="3"></textarea>
                            <div class="prompt-actions">
                                <button id="generate-btn" type="button">生成</button>
                                <button id="retry-btn" type="button">重试</button>
                                <button id="undo-gen-btn" type="button" style="display: none; background-color: #f8d7da; color: #721c24; border-color: #f5c6cb;" title="撤销上次生成的内容">撤销 [x]</button>
                                <button id="save-btn" type="button">保存</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 右侧设定书显示区 -->
        <div class="right-sidebar">
             <h3 id="right-sidebar-title">
                 <span class="book-title-text">设定详情</span>
                 <span class="word-count-badge" style="display: none;"></span> <!-- Initially hidden -->
             </h3>
            <div id="setting-content">
                <p>点击左侧设定书查看详情</p>
                <!-- 设定内容将由 JS 动态生成 -->
            </div>
        </div>
    </div>

    <!-- 右键菜单 -->
    <div id="context-menu" class="context-menu">
        <div data-action="rename">重命名</div>
        <div data-action="delete">删除</div>
    </div>

    <!-- 创建菜单 -->
     <div id="create-menu">
         <div data-type="folder">文件夹</div>
         <div data-type="book">书籍</div>
         <div data-type="setting">设定书</div>
     </div>


    <script>
        const fileList = document.getElementById('file-list');
        const contextMenu = document.getElementById('context-menu');
        const createMenu = document.getElementById('create-menu');
        const createBtn = document.getElementById('create-btn');
        const deleteBtn = document.getElementById('delete-btn');
        const settingContent = document.getElementById('setting-content');
        const novelContentDiv = document.getElementById('novel-content'); // The div for Quill
        let quill; // Quill instance

        const rightSidebarTitle = document.getElementById('right-sidebar-title');
        const bookTitleTextSpan = rightSidebarTitle.querySelector('.book-title-text'); 
        const wordCountBadgeSpan = rightSidebarTitle.querySelector('.word-count-badge'); 
        const autoSaveToggle = document.getElementById('auto-save-toggle'); 
        const centralDisplayArea = document.getElementById('central-display-area'); 
        const promptBar = document.querySelector('.prompt-bar'); 
        const templateSelect = document.getElementById('template-select');
        const wordCountInput = document.getElementById('word-count-input');
        const styleInput = document.getElementById('style-input');
        const promptInput = document.querySelector('.prompt-input'); 
        const generateBtn = document.getElementById('generate-btn');
        const aiServiceSelect = document.getElementById('ai-service-select'); 
        const undoGenBtn = document.getElementById('undo-gen-btn'); 

        let isGenerating = false; 
        const userPointsDisplayElement = document.getElementById('user-points-display'); 
        let lastGeneratedContentRange = null; // <-- 新增全局变量
        let currentEditorCursorPosition = 0; // <--- 新增：追踪当前编辑器光标的最后位置
        let userPrefBgColor = '#fff0f0'; // Default fallback background color
        let userPrefFontColor = null; // Default fallback font color (use editor default)
        let userPrefRetryPromptTemplate = ''; // Store user's retry prompt template
        let userPrefEnableMarkdown = false;
        let userPrefMarkdownTemplate = '';

        const EDITOR_STATE_KEY = 'novelEditorState';
        let isRestoringState = false; 
        let hasUnsavedChanges = false;

        function cleanupAiMarkup() { 
            // No longer relevant for Quill if inserting plain text or standard HTML
            return false; 
         }

        async function triggerGeneration(promptOverride = null) {
            if (isGenerating) {
                console.log('Generation already in progress, ignoring trigger.');
                return; 
            }
            isGenerating = true;
            generateBtn.disabled = true;
            generateBtn.textContent = '生成中...';
            
            // 清除之前AI生成内容的底纹 和 上次生成范围的记录
            if (quill) {
                // Clear both background and font color highlights from previous generation
                quill.formatText(0, quill.getLength(), 'background', false, 'silent');
                quill.formatText(0, quill.getLength(), 'color', false, 'silent'); 
            }
            lastGeneratedContentRange = null; // <-- 重置

            const selectedTemplateId = templateSelect.value;
            const selectedAiServiceId = aiServiceSelect.value; 

            if (!selectedTemplateId) {
                alert('请先选择一个提示词模板！');
                isGenerating = false;
                generateBtn.disabled = false;
                generateBtn.textContent = '生成';
                return;
            }

            const templateId = parseInt(selectedTemplateId, 10);
            const editorContentText = quill ? quill.getText() : ''; // Get plain text

            // --- 修改：确定插入点和要删除的选区长度 ---
            let initialInsertionPoint;
            let lengthToDelete = 0;

            if (quill) {
                const currentActiveSelection = quill.getSelection(); // 检查当前是否有活动的选区/光标
                if (currentActiveSelection) {
                    // 如果编辑器有焦点且有选区/光标，使用当前位置
                    initialInsertionPoint = currentActiveSelection.index;
                    lengthToDelete = currentActiveSelection.length; // 如果只是光标，length 为 0
                } else {
                    // 编辑器失去焦点，使用最后追踪到的光标位置
                    initialInsertionPoint = currentEditorCursorPosition;
                    // lengthToDelete 保持为 0，因为没有活动的选区可供删除
                }

                // 如果之前有选中的文本 (lengthToDelete > 0)，则删除它
                if (lengthToDelete > 0) {
                    quill.deleteText(initialInsertionPoint, lengthToDelete, 'user');
                }
            } else {
                initialInsertionPoint = 0; // Quill 未就绪时的备用方案
            }
            // --- 结束修改 ---
            
            const 前文 = editorContentText.substring(0, initialInsertionPoint);
            const 后文 = editorContentText.substring(initialInsertionPoint);
            
            // Determine the prompt: use override if provided, otherwise use input field
            const basePrompt = promptOverride !== null ? promptOverride : promptInput.value;
            
            // --- 恢复：将 basePrompt 和 userPrefMarkdownTemplate 合并为 finalPromptToSend ---
            // let finalPromptToSend = basePrompt; // This was the old combined prompt
            // if (userPrefEnableMarkdown && userPrefMarkdownTemplate && userPrefMarkdownTemplate.trim()) {
            // console.log("Markdown mode enabled, appending Markdown template to basePrompt.");
            // finalPromptToSend = basePrompt + '\\n\\n' + userPrefMarkdownTemplate.trim();
            // }
            // --- 结束恢复 ---

            // 恢复原始日志，并确保打印的是合并后的 finalPromptToSend
            console.log(`Cursor Index for generation: ${initialInsertionPoint}`);
            // console.log(`Using final prompt (to be processed by backend template): ${finalPromptToSend.substring(0,150)}...`);
            console.log(`Core prompt being sent: ${basePrompt.substring(0,150)}...`);
            console.log(`Markdown instruction being sent: ${ (userPrefEnableMarkdown && userPrefMarkdownTemplate && userPrefMarkdownTemplate.trim()) ? userPrefMarkdownTemplate.trim().substring(0,100) : '(empty)'}...`);
            console.log(`前文 (length ${前文.length}): \\"${前文.substring(0, 50)}...\\"`);
            console.log(`后文 (length ${后文.length}): \\"${后文.substring(0, 50)}...\\"`);

            const 字数 = parseInt(wordCountInput.value, 10) || 500;
            const 风格 = styleInput.value || '默认';
            const 设定 = [];
            const settingListElement = settingContent.querySelector('.setting-list');
            if (settingListElement) {
                const settingItems = settingListElement.querySelectorAll('.setting-item');
                settingItems.forEach(item => {
                    const checkbox = item.querySelector('.setting-enabled-toggle');
                    const textarea = item.querySelector('.setting-text-input');
                    if (checkbox && checkbox.checked && textarea && textarea.value.trim()) {
                        设定.push({ text: textarea.value.trim(), enabled: true });
                    }
                });
            }

            // --- 恢复：input_data['提示词'] 使用合并后的 finalPromptToSend ---
            const requestData = {
                template_id: templateId, 
                input_data: { 
                    '前文': 前文, 
                    '后文': 后文, 
                    '提示词': basePrompt, // 使用原始 basePrompt
                    '字数': 字数, 
                    '风格': 风格, 
                    '设定': 设定,
                    'markdown指令': (userPrefEnableMarkdown && userPrefMarkdownTemplate && userPrefMarkdownTemplate.trim()) ? userPrefMarkdownTemplate.trim() : ''
                    // 'markdown指令' 字段不再从这里单独发送，其内容已合并入 finalPromptToSend (如果启用)
                    // 后端 utils.py 中的 process_prompt_template 会处理模板中的 @[markdown] 占位符
                    // 如果 userPrefMarkdownTemplate 为空或未启用，则 @[markdown] 会被替换为空字符串
                }
            };
            // --- 结束恢复 ---
            
            if (selectedAiServiceId && selectedAiServiceId !== "") { 
                requestData.ai_service_config_id = parseInt(selectedAiServiceId, 10);
            } else {
                console.log("AI Service: Using user's default setting.");
            }

            console.log("准备发送到 /api/generate-with-template 的 requestData.input_data['提示词']:", requestData.input_data['提示词'].substring(0,200) + "...");
            console.log("准备发送到 /api/generate-with-template 的 requestData.input_data['markdown指令']:", requestData.input_data['markdown指令'].substring(0,100) + "...");

            try {
                const response = await fetch('/api/generate-with-template', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData)
                });
                
                const contentType = response.headers.get('content-type');

                if (response.ok) {
                    if (contentType && contentType.includes('text/plain')) {
                        console.log('接收到流式响应 (text/plain)，开始处理...');
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let accumulatedText = ''; 

                        if (quill) {
                            quill.focus();
                            let currentInsertPos = initialInsertionPoint; // Re-introduce for tracking live insertion

                        while (true) {
                            const { value, done } = await reader.read();
                            if (done) {
                                console.log('流结束。');
                                break;
                            }
                            const chunk = decoder.decode(value, { stream: true });
                                accumulatedText += chunk; // Accumulate text
                                
                                // --- Insert chunk directly for live preview (Re-added) ---
                                quill.insertText(currentInsertPos, chunk, 'user');
                                
                                // Apply formatting LIVE to the inserted chunk (Re-added)
                                if (userPrefBgColor) {
                                    quill.formatText(currentInsertPos, chunk.length, 'background', userPrefBgColor, 'silent'); // Use silent source for live formatting
                                }
                                if (userPrefFontColor) {
                                    quill.formatText(currentInsertPos, chunk.length, 'color', userPrefFontColor, 'silent'); // Use silent source for live formatting
                                }
                                
                                // Move insertion point forward
                                currentInsertPos += chunk.length;
                                // --- End direct insertion --- 
                            }

                            // --- 流结束后处理 ---
                            if (accumulatedText) {
                                const streamRange = { index: initialInsertionPoint, length: accumulatedText.length };

                                // 1. 清除先前实时流式文本的临时高亮
                                quill.formatText(streamRange.index, streamRange.length, 'background', false, 'silent');
                                quill.formatText(streamRange.index, streamRange.length, 'color', false, 'silent');

                                // 2. 从编辑器中删除原始的流式文本
                                quill.deleteText(streamRange.index, streamRange.length, 'silent');

                                // 3. 将累积的原始文本 (accumulatedText) 解析为 Markdown HTML
                                let generatedHtml = '';
                                try {
                                    generatedHtml = marked.parse(accumulatedText);
                                    console.log("Markdown 文本成功解析为 HTML:\n", generatedHtml.substring(0, 200) + "...");
                                } catch (parseError) {
                                    console.error("Markdown 解析失败，将插入原始文本:", parseError);
                                    generatedHtml = accumulatedText; // 如果解析失败，则退回使用原始文本 (基本不会发生，marked会处理纯文本)
                                }

                                // 4. 将解析后的 HTML (或原始文本) 重新插入编辑器
                                quill.clipboard.dangerouslyPasteHTML(streamRange.index, generatedHtml, 'user');

                                // 5. 对新插入的、已渲染的内容重新应用高亮格式
                                // 注意：HTML渲染后的实际长度可能与原始文本不同，但高亮通常基于原始文本范围视觉上可接受
                                if (userPrefBgColor) {
                                    quill.formatText(streamRange.index, accumulatedText.length, 'background', userPrefBgColor, 'user');
                                }
                                if (userPrefFontColor) {
                                    quill.formatText(streamRange.index, accumulatedText.length, 'color', userPrefFontColor, 'user');
                                }
                                
                                // 更新 lastGeneratedContentRange 以便重试功能可以正确删除渲染后的内容
                                // 长度仍使用 accumulatedText.length，因为这是AI原始内容的长度，重试时AI基于此调整
                                lastGeneratedContentRange = { index: streamRange.index, length: accumulatedText.length };
                                quill.setSelection(streamRange.index + accumulatedText.length); // 将光标移至渲染内容之后
                                
                                console.log('流式生成成功。内容已移除并作为Markdown重新插入。');
                            }
                        }
                    } else { // Non-streaming path (Keep existing logic: directly insert parsed HTML if MD enabled)
                        console.log('接收到成功的非流式响应，尝试解析 JSON...');
                        const result = await response.json();
                        if (result && result.generated_text) {
                           const generatedText = result.generated_text;
                            if (quill) {
                                const lengthToHighlight = generatedText.length;
                                if (userPrefEnableMarkdown) {
                                    console.log("Markdown enabled, rendering HTML from non-stream.");
                                    console.log("Received Text:\n", generatedText);
                                    try {
                                        const generatedHtml = marked.parse(generatedText);
                                        console.log("Generated HTML:\n", generatedHtml);
                                        quill.clipboard.dangerouslyPasteHTML(initialInsertionPoint, generatedHtml, 'user');
                                    } catch (parseError) {
                                        console.error("Markdown parsing failed, inserting as plain text:", parseError);
                                        quill.insertText(initialInsertionPoint, generatedText, 'user');
                                    }
                                } else {
                                    console.log("Markdown disabled, inserting plain text from non-stream.");
                                    quill.insertText(initialInsertionPoint, generatedText, 'user');
                                }

                                if (userPrefBgColor) {
                                    quill.formatText(initialInsertionPoint, lengthToHighlight, 'background', userPrefBgColor, 'user');
                                }
                                if (userPrefFontColor) {
                                    quill.formatText(initialInsertionPoint, lengthToHighlight, 'color', userPrefFontColor, 'user');
                                }
                                lastGeneratedContentRange = { index: initialInsertionPoint, length: lengthToHighlight };
                                quill.setSelection(initialInsertionPoint + lengthToHighlight);
                                quill.focus();
                            }
                            console.log('非流式生成成功，插入文本。');
                        } else {
                           console.warn("API 调用成功但未收到 generated_text", result);
                           throw new Error('AI 服务未返回有效内容。');
                       }
                    } // End of if (contentType...)

                    // Update sidebar title and unsaved changes flag only after content is processed
                    if (quill && currentEditingBookTitle && novelContentDiv.dataset.currentItemType === 'book') {
                        updateRightSidebarTitle(currentEditingBookTitle, quill.getText());
                    }
                    if (!isRestoringState) {
                        hasUnsavedChanges = true;
                        console.log('Unsaved changes after generation (Quill).');
                    }

                } else { // Handle non-OK response
                     console.log(`接收到失败响应 (状态码: ${response.status})，尝试解析 JSON 错误...`);
                    const result = await response.json();
                     throw new Error(result.error || `HTTP error! status: ${response.status}`);
                }
                 
            } catch (error) { // Catch block for the main try around fetch
                console.error('生成内容或处理响应时出错:', error);
                let errorMessage = error.message;
                if (errorMessage.startsWith('Error: ')) errorMessage = errorMessage.substring(7);
                 if (error instanceof SyntaxError && errorMessage.includes('JSON')) {
                     errorMessage = "无法解析服务器响应，可能是空的或格式错误。请检查服务器日志。";
                 } 
                alert(`生成失败: ${errorMessage}`);
            } finally { // Finally block for the main try around fetch
                 generateBtn.textContent = '生成';
                 generateBtn.disabled = false;
                isGenerating = false;
                updateUserPointsDisplay();
            }
        } // End of triggerGeneration function

        async function updateUserPointsDisplay() {
            if (!userPointsDisplayElement) return;
            try {
                const response = await fetch('/api/user/status');
                if (response.ok) {
                const userData = await response.json();
                if (userData && userData.points !== undefined) {
                    userPointsDisplayElement.innerHTML = `<i class="fas fa-coins"></i> ${userData.points}`;
                }
            }
            } catch (error) { console.error('Error fetching user points:', error); }
        }

        if (promptInput && generateBtn) {
            promptInput.addEventListener('keydown', (event) => {
                if (event.key === 'Enter' && !event.shiftKey) {
                    event.preventDefault(); triggerGeneration(); 
                }
            });
        }

        let contextTarget = null;
        let draggedItemData = null;
        let currentDragTargetElement = null;
        let insertPosition = null;
        let currentEditingBookTitle = null;
        let isWordCountLimitAlertShown = false; 
        let autoSaveTimer = null; 
        const AUTO_SAVE_DELAY = 1500; 
        let isAutoSaveOnNavigateEnabled = false; 

        async function fetchAPI(url, options = {}) {
            const headers = { 'Content-Type': 'application/json', 'Accept': 'application/json', ...(options.headers || {}) };
            if (options.body && typeof options.body !== 'string') options.body = JSON.stringify(options.body);
            try {
                const response = await fetch(url, { ...options, headers });
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: `Request failed: ${response.status}` }));
                    alert(`操作失败: ${errorData.error || '未知错误'}`); return null; 
                }
                if (response.status === 204 || response.headers.get('Content-Length') === '0') return { success: true }; 
                return await response.json();
            } catch (error) { alert('网络错误或请求失败'); return null; }
        }

        async function fetchItems(parentId = 'root') { return await fetchAPI(`/api/items?parent_id=${parentId}`); }
        async function createItemAPI(name, type, parentId = 'root') { return await fetchAPI('/api/items', { method: 'POST', body: { name, type, parentId } }); }
        async function deleteItemAPI(itemId) { return await fetchAPI(`/api/items/${itemId}`, { method: 'DELETE' }); }
        async function renameItemAPI(itemId, newName) { return await fetchAPI(`/api/items/${itemId}/rename`, { method: 'PUT', body: { name: newName } }); }
        async function moveItemAPI(itemId, targetParentId, targetBeforeId = null) { return await fetchAPI(`/api/items/${itemId}/move`, { method: 'PUT', body: { targetParentId, targetBeforeId } }); }
        async function getContentAPI(itemId) { return await fetchAPI(`/api/items/${itemId}/content`); }
        async function updateContentAPI(itemId, type, data) {
            const body = (type === 'book') ? { content: data } : (type === 'setting') ? { settings: data } : {};
            return await fetchAPI(`/api/items/${itemId}/content`, { method: 'PUT', body });
        }
        async function toggleFolderAPI(itemId, collapsed) { return await fetchAPI(`/api/items/${itemId}/toggle`, { method: 'PUT', body: { collapsed } }); }
        async function associateSettingAPI(bookId, settingBookId) { return await fetchAPI(`/api/items/${bookId}/associate_setting`, { method: 'POST', body: { settingBookId } }); }

        function countCharacters(htmlText) { // Counts chars in plain text derived from HTML
            if (!htmlText) return 0;
            // Use Quill's delta/plain text conversion if available, otherwise fallback
            if (quill && quill.clipboard.convert) {
                 try {
                      // Convert HTML to Delta, then get text length
                      const delta = quill.clipboard.convert(htmlText);
                      let length = 0;
                      delta.ops.forEach(op => {
                           if (typeof op.insert === 'string') {
                                length += op.insert.length;
                           } else if (typeof op.insert === 'object') { 
                                // Handle embeds like images - count as 1 character? Or ignore?
                                length += 1; 
                           }
                      });
                      return length;
                 } catch(e) {
                      console.warn("Quill conversion failed for count, falling back to textContent", e);
                 }
            }
            // Fallback: simpler textContent extraction
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = htmlText;
            return tempDiv.textContent.length || tempDiv.innerText.length || 0;
        }

        async function saveCurrentBookContent() {
            const currentId = novelContentDiv.dataset.currentItemId; // Use the div's dataset
            const currentType = novelContentDiv.dataset.currentItemType;
            const saveBtn = document.getElementById('save-btn'); 
            
            if (saveBtn?.classList.contains('save-success')) saveBtn.classList.remove('save-success');

            if (quill && currentId && currentType === 'book') {
                if (saveBtn) { saveBtn.disabled = true; saveBtn.textContent = '保存中...'; }
                
                // 保存前清除AI生成内容的底纹和字体颜色
                quill.formatText(0, quill.getLength(), 'background', false, 'silent');
                quill.formatText(0, quill.getLength(), 'color', false, 'silent');

                const contentToSave = quill.root.innerHTML; // Get HTML content from Quill
                const result = await updateContentAPI(currentId, currentType, contentToSave);
                if (saveBtn) { saveBtn.disabled = false; saveBtn.textContent = '保存'; }

                if (result) {
                    hasUnsavedChanges = false;
                    console.log('[Save Success] Content saved successfully.');
                    if (saveBtn) {
                        saveBtn.classList.add('save-success');
                        setTimeout(() => { saveBtn.classList.remove('save-success'); }, 1500); 
                    }
                    updateRightSidebarTitle(currentEditingBookTitle, quill.getText()); // Count text
                } else {
                     if (saveBtn) {
                        saveBtn.textContent = '保存失败!';
                        setTimeout(() => { if (!saveBtn.disabled) saveBtn.textContent = '保存'; }, 2000);
                     }
                }
            } else {
                console.log('[Save Skipped] No active quill, book selected, or not editing a book.');
            }
        }

        function renderFileList(data, parentElement) {
            parentElement.innerHTML = ''; 
            if (!data || !Array.isArray(data)) {
                parentElement.innerHTML = '<li>加载失败或无数据</li>'; return;
            }
            data.forEach(item => {
                const li = document.createElement('li');
                li.className = 'file-item';
                li.dataset.id = item.id; li.dataset.type = item.type;
                if (item.type === 'folder' && item.collapsed) li.classList.add('collapsed');
                li.draggable = true;
                let iconClass = item.type === 'folder' ? 'fa-folder' : item.type === 'book' ? 'fa-book' : 'fa-scroll';
                let toggleIcon = item.type === 'folder' ? `<i class="fas fa-chevron-right folder-toggle"></i>` : '';
                li.innerHTML = `${toggleIcon}<i class="fas ${iconClass}"></i><span class="item-name">${item.name}</span>`;
                ['click', 'contextmenu', 'dragstart', 'dragenter', 'dragover', 'dragleave', 'drop'].forEach(eName => {
                    li.addEventListener(eName, (event) => {
                        if (eName === 'click') handleItemClick(event, item, li);
                        else if (eName === 'contextmenu') showContextMenu(event, li, item);
                        else if (eName === 'dragstart') handleDragStart(event, item, li);
                        else if (eName === 'dragenter') handleDragEnter(event, item, li);
                        else if (eName === 'dragover') handleDragOver(event, item, li);
                        else if (eName === 'dragleave') handleDragLeave(event, li);
                        else if (eName === 'drop') handleDrop(event, item, li);
                    });
                });
                parentElement.appendChild(li);
                if (item.type === 'folder') {
                    const ul = document.createElement('ul');
                    ul.style.display = item.collapsed ? 'none' : 'block'; 
                    li.appendChild(ul);
                }
            });
        }

        async function handleItemClick(event, itemData, itemElement) {
             event.stopPropagation();
            if (!isRestoringState) saveEditorState();

            const prevItemId = novelContentDiv.dataset.currentItemId;
            const prevItemType = novelContentDiv.dataset.currentItemType;
            if (isAutoSaveOnNavigateEnabled && prevItemId && prevItemType === 'book' && prevItemId !== String(itemData.id)) {
                 await saveCurrentBookContent();
            }
            currentEditingBookTitle = null; isWordCountLimitAlertShown = false; 

            if (itemData.type === 'folder') {
                showEditorArea(); 
                if(quill) quill.setText(''); // Clear editor
                Object.assign(novelContentDiv.dataset, { currentItemId: '', currentItemType: '' });
                clearSettingDisplay(); updateRightSidebarTitle('设定详情'); 
                const isCollapsed = itemElement.classList.toggle('collapsed');
                const childrenUl = itemElement.querySelector('ul');
                await toggleFolderAPI(itemData.id, isCollapsed); 
                if (!isCollapsed && childrenUl && childrenUl.children.length === 0) {
                    childrenUl.innerHTML = '<li><i>加载中...</i></li>';
                    const childrenData = await fetchItems(itemData.id);
                    if (childrenData) renderFileList(childrenData, childrenUl); else childrenUl.innerHTML = '<li><i>加载失败</i></li>';
                }
                if (childrenUl) childrenUl.style.display = isCollapsed ? 'none' : 'block';
            } else if (itemData.type === 'book') {
                await openBook(itemData); 
            } else if (itemData.type === 'setting') {
                if(quill) quill.setText(''); 
                Object.assign(novelContentDiv.dataset, { currentItemId: '', currentItemType: '' });
                clearSettingDisplay(); updateRightSidebarTitle('设定详情'); 
                const settingDetails = await getContentAPI(itemData.id);
                if (settingDetails?.associatedBookInfo) {
                    await openBook(settingDetails.associatedBookInfo); 
                } else if (settingDetails) {
                    showCentralDisplay(); 
                    const books = await getUnassociatedBooksAPI();
                    renderUnassociatedBookList(books, itemData.id, centralDisplayArea);
                    clearSettingDisplay(); updateRightSidebarTitle(`关联《${itemData.name}》`); 
                 } else {
                    showEditorArea(); alert('加载设定书信息失败。');
                }
            }
        }

        function displaySettingDetails(settingItem) { /* ... function remains the same ... */
            settingContent.innerHTML = ''; 
            const headerDiv = document.createElement('div');
            headerDiv.className = 'setting-header';
            const titleH3 = document.createElement('h3');
            titleH3.textContent = settingItem.name;
            headerDiv.appendChild(titleH3);
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'setting-actions';
            actionsDiv.innerHTML = `<button id="add-setting-btn" title="添加新设定">+</button><button id="save-settings-btn" title="保存当前设定书的更改">保存设定</button>`;
            headerDiv.appendChild(actionsDiv);
            settingContent.appendChild(headerDiv);
            const settingList = document.createElement('ul');
            settingList.className = 'setting-list';
            settingList.dataset.settingBookId = settingItem.id; 
            const settingsData = settingItem.settings || [];
            if (settingsData.length > 0) {
                settingsData.forEach((s, i) => settingList.appendChild(createSettingItemElement(s, i)));
             } else {
                const p = document.createElement('p');
                p.textContent = '暂无详细设定，点击 "+" 添加。';
                p.style.cssText = 'text-align: center; color: #6c757d; margin-top: 20px;';
                settingList.appendChild(p); 
            }
            settingContent.appendChild(settingList);
        }
        function createSettingItemElement(settingData, index) { /* ... function remains the same ... */
            const li = document.createElement('li');
            li.className = 'setting-item'; li.dataset.index = index; 
            const text = settingData.text || '';
            const enabled = settingData.enabled ?? true; 
            li.innerHTML = `<div class="setting-item-controls"><input type="checkbox" class="setting-enabled-toggle" ${enabled ? 'checked' : ''} title="是否启用此设定"></div><textarea class="setting-text-input" rows="1">${text}</textarea><div class="setting-item-controls"><button class="delete-setting-btn" title="删除此设定">-</button></div>`;
            const textarea = li.querySelector('textarea');
            adjustTextareaHeight(textarea);
            textarea.addEventListener('input', () => adjustTextareaHeight(textarea));
            return li;
        }
        function adjustTextareaHeight(textarea) { /* ... function remains the same ... */
            textarea.style.height='auto'; textarea.style.height=textarea.scrollHeight+'px';
         }

        settingContent.addEventListener('click', async (event) => { /* ... function logic remains the same ... */
            const target = event.target;
            if (target.id === 'add-setting-btn') {
                const list = settingContent.querySelector('.setting-list');
                if (list) { const item = createSettingItemElement({}, list.children.length); list.appendChild(item); item.querySelector('textarea').focus(); }
            } else if (target.classList.contains('delete-setting-btn')) {
                target.closest('.setting-item')?.remove();
            } else if (target.id === 'save-settings-btn') {
                await autoSaveSettings(); 
                if (!target.disabled) { target.textContent = '已保存 ✓'; setTimeout(() => { if(!target.disabled) target.textContent='保存设定'; }, 2000); }
            }
        });

        function showContextMenu(event, element, item) { /* ... function remains the same ... */
            event.preventDefault(); event.stopPropagation();
            contextTarget = { element, item };
            Object.assign(contextMenu.style, { top: `${event.clientY}px`, left: `${event.clientX}px`, display: 'block' });
        }
        function hideContextMenu() { /* ... function remains the same ... */
            contextMenu.style.display='none'; contextTarget=null;
         }
        function showCreateMenu(event) { /* ... function remains the same ... */
            event.stopPropagation();
             const rect = createBtn.getBoundingClientRect();
            Object.assign(createMenu.style, { top: `${rect.bottom + 5}px`, left: `${rect.left}px`, display: 'block' });
         }
        function hideCreateMenu() { /* ... function remains the same ... */
            createMenu.style.display='none';
         }
        function startRename(target) { /* ... function remains the same ... */
            const span = target.element.querySelector('.item-name'); if (!span) return;
            const { name: currentName, id: itemId } = target.item;
            const input = document.createElement('input');
            input.type='text'; input.value=currentName; input.className='rename-input';
            span.replaceWith(input); input.focus(); input.select();
            const finish = async (save) => {
                input.removeEventListener('blur', onBlur); input.removeEventListener('keydown', onKeydown);
                 const newName = input.value.trim();
                if (save && newName && newName !== currentName) {
                    const updated = await renameItemAPI(itemId, newName);
                    if (updated) { const newSpan = document.createElement('span'); newSpan.className='item-name'; newSpan.textContent=updated.name; input.replaceWith(newSpan); target.item.name=updated.name; }
                    else { input.replaceWith(span); alert('重命名失败'); }
                } else input.replaceWith(span);
            };
            const onBlur = () => finish(true); const onKeydown = (e) => { if(e.key==='Enter') finish(true); else if(e.key==='Escape') finish(false); };
            input.addEventListener('blur', onBlur); input.addEventListener('keydown', onKeydown);
         }
        async function deleteItem(targetItemData) { /* ... function remains the same, uses novelContentDiv dataset */
            const { name: itemName, id: itemId, type: itemType, parent_id: originalParentId = 'root' } = targetItemData;
            if (confirm(`确定要删除 ${itemName} 吗？${itemType === 'folder' ? ' (其内容也将被删除)' : ''}`)) {
                const result = await deleteItemAPI(itemId);
                if (result) { 
                    fileList.querySelector(`.file-item[data-id="${itemId}"]`)?.remove();
                    if (novelContentDiv.dataset.currentItemId == itemId) {
                         if(quill) quill.setText('');
                         Object.assign(novelContentDiv.dataset, { currentItemId: '', currentItemType: '' });
                         currentEditingBookTitle = null; isWordCountLimitAlertShown = false; 
                         updateRightSidebarTitle('设定详情'); clearSettingDisplay();
                    }
                    if (settingContent.dataset.currentItemId == itemId) clearSettingDisplay(); 
                    await reloadItemsForParent(originalParentId === 'root' ? null : originalParentId);
                }
            }
         }
        async function createNewItem(type) { /* ... function remains the same ... */
            const name = `新${type === 'folder' ? '文件夹' : type === 'book' ? '书籍' : '设定书'}`;
            const newItem = await createItemAPI(name, type, 'root');
            if(newItem){ await loadInitialItems(); setTimeout(() => { const el = fileList.querySelector(`.file-item[data-id="${newItem.id}"]`); if(el) startRename({element:el, item:newItem}); },100); }
         }

        function handleDragStart(event, itemData, element) { /* ... function remains the same ... */
            event.stopPropagation(); draggedItemData = itemData; event.dataTransfer.setData('text/plain', itemData.id); event.dataTransfer.effectAllowed = 'move';
            const div = document.createElement('div'); Object.assign(div.style, { display:'inline-flex', alignItems:'center', backgroundColor:'rgba(100,150,250,0.7)', padding:'5px 10px', borderRadius:'4px', position:'absolute', top:'-100px', left:'-1000px', pointerEvents:'none', fontFamily:'inherit', fontSize:'15px', color:'#fff' });
            const icon = element.querySelector('i.fas:not(.folder-toggle)'); const span = element.querySelector('.item-name');
            if(icon) { const iClone=icon.cloneNode(true); iClone.style.cssText='margin-right:8px;color:#fff;'; div.appendChild(iClone); }
            if(span) { const sClone=document.createElement('span'); sClone.textContent=span.textContent; div.appendChild(sClone); }
            document.body.appendChild(div); event.dataTransfer.setDragImage(div,15,15);
            setTimeout(()=>{element.classList.add('dragging'); if(document.body.contains(div)) document.body.removeChild(div);},0);
        }
        function handleDragEnter(event, targetItemData, targetElement) { /* ... function remains the same ... */
            event.preventDefault(); currentDragTargetElement = targetElement;
         }
        function handleDragOver(event, targetItemData, targetElement) { /* ... function remains the same ... */
             event.preventDefault(); event.dataTransfer.dropEffect = 'move';
             const dType=draggedItemData?.type; const tType=targetElement?.dataset.type;
             if(!draggedItemData || !targetElement || targetElement.dataset.id === String(draggedItemData.id)) { clearDropClasses(); insertPosition=null; return; }
             clearDropClasses(targetElement); const rect=targetElement.getBoundingClientRect(); const mid=rect.top+rect.height/2; insertPosition=null;
             if(dType==='setting' && tType==='book'){targetElement.classList.add('drag-over-associate'); insertPosition='associate';}
             else if(tType==='folder'){ const thresh=rect.height*0.2; if(event.clientY<rect.top+thresh){targetElement.classList.add('drag-over-insert-before'); insertPosition='before';} else if(event.clientY>rect.bottom-thresh){targetElement.classList.add('drag-over-insert-after'); insertPosition='after';} else {targetElement.classList.add('drag-over-folder'); insertPosition='folder';}}
             else if(insertPosition!=='associate'){if(event.clientY<mid){targetElement.classList.add('drag-over-insert-before'); insertPosition='before';} else {targetElement.classList.add('drag-over-insert-after'); insertPosition='after';}}
             const delTarget=event.target.closest('#delete-btn');
             if(delTarget){clearDropClasses(); delTarget.classList.add('drag-over-delete'); insertPosition='delete'; currentDragTargetElement=delTarget;} else if(currentDragTargetElement===deleteBtn){deleteBtn.classList.remove('drag-over-delete'); currentDragTargetElement=targetElement||null;}
        }
        function handleDragLeave(event, element) { /* ... function remains the same ... */
             if(element) element.classList.remove('drag-over-folder','drag-over-insert-before','drag-over-insert-after','drag-over-associate');
             if(event.target.id==='delete-btn'||element===deleteBtn) deleteBtn.classList.remove('drag-over-delete');
             if(!event.relatedTarget||(!event.relatedTarget.closest('.file-item')&&event.relatedTarget.id!=='delete-btn')) insertPosition=null;
        }
        async function handleDrop(event, targetItemData, targetElement) { /* ... function remains the same, uses novelContentDiv dataset */
            event.preventDefault(); event.stopPropagation();
            const { insertPosition: currentIP, draggedItemData: currentDID } = { insertPosition, draggedItemData };
            const draggedId = currentDID?.id; const origParentId = currentDID?.parent_id || 'root';
            clearDropClasses(); cleanupDragState(); if (!draggedId || !currentIP || (targetElement && targetElement.dataset.id === String(draggedId))) return;
            if (currentIP === 'delete') { if (currentDID) await deleteItem(currentDID); }
            else if (currentIP === 'associate' && currentDID.type === 'setting' && targetItemData.type === 'book') {
                const result = await associateSettingAPI(targetItemData.id, draggedId);
                if(result){alert(`《${targetItemData.name}》关联成功`); if(novelContentDiv.dataset.currentItemId == targetItemData.id){ const content = await getContentAPI(targetItemData.id); if(content?.associatedSetting){const setting = await getContentAPI(content.associatedSetting.id); if(setting) displaySettingDetails(setting); else clearSettingDisplay();}}}
                } else {
                let targetParentAPI = null, beforeId = null; const targetParentDOM = targetItemData?.parent_id || 'root';
                if (currentIP === 'folder' && targetItemData?.type === 'folder') targetParentAPI = targetItemData.id;
                else if (currentIP === 'before' && targetItemData) { targetParentAPI = targetParentDOM==='root'?null:targetParentDOM; beforeId = targetItemData.id; }
                else if (currentIP === 'after' && targetItemData) { targetParentAPI = targetParentDOM==='root'?null:targetParentDOM; const next=targetElement.nextElementSibling; if(next?.classList.contains('file-item')) beforeId = next.dataset.id; }
                if (currentDID?.type === 'folder' && String(draggedId) === String(targetParentAPI)) { alert("不能移动文件夹到自身内部"); return; }
                const result = await moveItemAPI(draggedId, targetParentAPI, beforeId);
                if (result) { await reloadItemsForParent(origParentId==='root'?null:origParentId); const newParentActual = targetParentAPI||'root'; if (origParentId !== newParentActual) await reloadItemsForParent(newParentActual==='root'?null:newParentActual); }
            }
        }
        async function reloadItemsForParent(parentId) { /* ... function remains the same ... */
             const parentIdStr=parentId||'root'; let targetUl=(parentIdStr==='root')?fileList:fileList.querySelector(`.file-item[data-id="${parentId}"]`)?.querySelector('ul');
             if(!targetUl){console.error('Cannot find UL for parent:', parentId); return;}
             const items = await fetchItems(parentIdStr); if(items) renderFileList(items, targetUl); else targetUl.innerHTML='<li><i>加载失败</i></li>';
         }
        function cleanupDragState() { /* ... function remains the same ... */
             if(draggedItemData){ document.querySelector(`.file-item[data-id="${draggedItemData.id}"].dragging`)?.classList.remove('dragging'); }
             draggedItemData=null; currentDragTargetElement=null; insertPosition=null; clearDropClasses();
         }
        function clearDropClasses(excludeElement = null) { /* ... function remains the same ... */
            document.querySelectorAll('.file-item.drag-over-folder, .file-item.drag-over-insert-before, .file-item.drag-over-insert-after, .file-item.drag-over-associate').forEach(el=>{if(el!==excludeElement)el.classList.remove('drag-over-folder','drag-over-insert-before','drag-over-insert-after','drag-over-associate');}); deleteBtn.classList.remove('drag-over-delete');
         }
        document.addEventListener('dragend', () => { cleanupDragState(); });

        async function loadInitialItems() { /* ... function remains the same, calls loadEditorState */
             const rootItems = await fetchItems('root');
             if (rootItems) { renderFileList(rootItems, fileList); await loadEditorState(); }
             else { fileList.innerHTML = '<li>加载根目录失败</li>'; }
         }

        document.addEventListener('DOMContentLoaded', () => {
            const toolbarOptions = [
                ['bold', 'italic', 'underline', 'strike'],        // toggled buttons
                ['blockquote', 'code-block'],
                // [{ 'header': 1 }, { 'header': 2 }],            // custom button values (optional)
                [{ 'list': 'ordered'}, { 'list': 'bullet' }],
                // [{ 'script': 'sub'}, { 'script': 'super' }],      // superscript/subscript (optional)
                [{ 'indent': '-1'}, { 'indent': '+1' }],          // outdent/indent
                // [{ 'direction': 'rtl' }],                         // text direction (optional)
                [{ 'size': ['small', false, 'large', 'huge'] }],  // custom dropdown
                [{ 'header': [1, 2, 3, 4, 5, 6, false] }],
                [{ 'color': [] }, { 'background': [] }],          // dropdown with defaults from theme
                [{ 'font': [] }],
                [{ 'align': [] }],
                ['clean']                                         // remove formatting button
            ];

            quill = new Quill('#novel-content', {
                modules: {
                    toolbar: toolbarOptions
                },
                placeholder: '在这里编辑你的小说内容...',
                theme: 'snow' // 'snow' is a common theme with a toolbar
            });

            // Event listener for text changes in Quill
            quill.on('text-change', (delta, oldDelta, source) => {
                if (source === 'user') { // Only track user changes for unsaved flag
                    if (!isRestoringState) {
                        hasUnsavedChanges = true;
                        console.log('Unsaved changes detected (Quill).');
                    }
                    // Update word count on change
                    if (currentEditingBookTitle && novelContentDiv.dataset.currentItemType === 'book') {
                        updateRightSidebarTitle(currentEditingBookTitle, quill.getText());
                    }
                     // Could trigger debounced saveEditorState() here if needed
                }
            });

            // --- 新增：监听选区变化以追踪光标位置 ---
            quill.on('selection-change', function(range, oldRange, source) {
                if (source === 'user') {
                    if (range) {
                        // 当选区存在 (编辑器有焦点)，更新最后已知的光标位置
                        currentEditorCursorPosition = range.index;
                        // console.log(`Cursor position updated to: ${currentEditorCursorPosition}`);
                    }
                    // 如果 range 为 null, 表示编辑器失去焦点, currentEditorCursorPosition 保留其最后的值
                }
            });
            // --- 结束新增监听器 ---

            // --- Function to load user AI preferences ---
            async function loadAndApplyUserAiPreferences() {
                console.log("Loading user AI preferences for editor highlighting...");
                try {
                    const response = await fetch('/api/user/ai-preferences');
                    if (!response.ok) {
                        console.warn(`Failed to fetch AI preferences: ${response.status}. Using defaults.`);
                        // Keep default fallbacks defined globally
                    return;
                 }
                    const prefs = await response.json();
                    
                    // Construct RGB strings for background color
                    const bgR = prefs.ai_bg_color_r !== null ? prefs.ai_bg_color_r : 255;
                    const bgG = prefs.ai_bg_color_g !== null ? prefs.ai_bg_color_g : 240;
                    const bgB = prefs.ai_bg_color_b !== null ? prefs.ai_bg_color_b : 240;
                    userPrefBgColor = `rgb(${bgR}, ${bgG}, ${bgB})`;
                    
                    // Construct RGB string for font color (only if valid)
                    const fontR = prefs.ai_font_color_r !== null ? prefs.ai_font_color_r : null; // Use null if not set
                    const fontG = prefs.ai_font_color_g !== null ? prefs.ai_font_color_g : null;
                    const fontB = prefs.ai_font_color_b !== null ? prefs.ai_font_color_b : null;
                    if (fontR !== null && fontG !== null && fontB !== null) {
                        userPrefFontColor = `rgb(${fontR}, ${fontG}, ${fontB})`;
                 } else {
                        userPrefFontColor = null; // Ensure it's null if any part is missing
                    }
                    
                    // --- Load Retry Prompt Template ---
                    userPrefRetryPromptTemplate = prefs.retry_prompt_template || '';
                    console.log(`User AI Prefs Loaded: BG=${userPrefBgColor}, Font=${userPrefFontColor}, RetryTemplate: ${userPrefRetryPromptTemplate.substring(0, 50)}...`);

                    // --- Load Markdown Preferences ---
                    userPrefEnableMarkdown = prefs.enable_markdown_prompt || false;
                    userPrefMarkdownTemplate = prefs.markdown_prompt_template || '';
                    console.log(`User AI Prefs Loaded: ... Markdown Enabled=${userPrefEnableMarkdown}, MD Template=${userPrefMarkdownTemplate.substring(0, 50)}...`);

                } catch (error) {
                    console.error('Error loading user AI preferences:', error);
                    // Keep default fallbacks on error
                }
            }
            // --- End Function ---

            // Initial load sequence
            Promise.all([
                loadAndApplyUserAiPreferences(), // Load AI prefs first
                populateTemplateSelector(),
                populateAiServiceSelector()
            ]).then(() => {
                loadInitialItems(); // loadInitialItems now calls loadEditorState
            }).catch(error => {
                console.error("Error during initial population of selectors:", error);
                loadInitialItems(); // Attempt to load items even if selectors fail
            });

            if (autoSaveToggle) { /* ... autoSaveToggle logic remains the same ... */
                 let initialAutoSaveSetting = autoSaveToggle.dataset.initialState === 'true';
                    isAutoSaveOnNavigateEnabled = initialAutoSaveSetting;
                    autoSaveToggle.checked = isAutoSaveOnNavigateEnabled;
                 autoSaveToggle.addEventListener('change', async () => { 
                    isAutoSaveOnNavigateEnabled = autoSaveToggle.checked;
                    const result = await updateUserSettingAPI('auto_save_on_navigate', isAutoSaveOnNavigateEnabled);
                     if (!result?.success) {
                          autoSaveToggle.checked = !isAutoSaveOnNavigateEnabled; isAutoSaveOnNavigateEnabled = !isAutoSaveOnNavigateEnabled; alert('无法保存设置');
                     }
                 });
             }

            const saveBtn = document.getElementById('save-btn');
            if (saveBtn) saveBtn.addEventListener('click', async () => { await saveCurrentBookContent(); });
            if (generateBtn) generateBtn.addEventListener('click', triggerGeneration); 
            if (undoGenBtn) undoGenBtn.style.display = 'none';

            const retryBtn = document.getElementById('retry-btn');
            if (retryBtn) {
                retryBtn.addEventListener('click', async () => {
                    if (isGenerating) {
                        console.log('Generation in progress, retry ignored.');
                        return;
                    }
                    
                    let promptForRetry = null; // Variable to hold the potentially modified prompt
                    let originalPrompt = promptInput.value; // Get current prompt text

                    // If there was a previously generated segment tracked, delete it and prepare retry prompt.
                    if (lastGeneratedContentRange && quill) {
                        let lastResponseText = '';
                        try {
                            // Get the text of the last response before deleting
                            lastResponseText = quill.getText(lastGeneratedContentRange.index, lastGeneratedContentRange.length);
                            console.log('Retrieved last response for retry:', lastResponseText.substring(0, 50) + '...');
                            
                            quill.deleteText(lastGeneratedContentRange.index, lastGeneratedContentRange.length, 'user');
                            console.log('Previous AI content deleted for retry.');
                        } catch (e) {
                            console.error('Error getting/deleting previous AI content:', e);
                            // Proceed with generation anyway, old highlight will be cleared by triggerGeneration.
                        }
                        lastGeneratedContentRange = null; // Reset it after attempting deletion
                        
                        // Check if user has a retry template and process it
                        if (userPrefRetryPromptTemplate && userPrefRetryPromptTemplate.trim()) {
                            console.log('Applying retry template:', userPrefRetryPromptTemplate);
                            // Replace placeholder with the actual last response text
                            const processedRetryTemplate = userPrefRetryPromptTemplate.replace(/@\[原回复\]/g, lastResponseText);
                            // Combine original prompt with the processed retry template
                            promptForRetry = originalPrompt + '\n\n' + processedRetryTemplate; 
                            console.log('Combined prompt for retry:', promptForRetry.substring(0, 100) + '...');
             } else {
                            console.log('No retry template set, retrying with original prompt.');
                            promptForRetry = originalPrompt; // Use original prompt if no template
                        }
                     } else {
                        // If no previous generation tracked, just use the current prompt (like normal generation)
                        console.log('No previous generation tracked, retry acts like generate.');
                         promptForRetry = originalPrompt; 
                    }
                    
                    // Now, trigger a new generation, passing the combined prompt if modified
                    // triggerGeneration will clear any remaining pink highlights and reset lastGeneratedContentRange before generating.
                    await triggerGeneration(promptForRetry);
                });
            }
        });

        document.addEventListener('click', () => { hideContextMenu(); hideCreateMenu(); });
        contextMenu.addEventListener('click', (event) => { /* ... unchanged ... */
             if(contextTarget&&event.target.dataset.action){const act=event.target.dataset.action; if(act==='rename')startRename(contextTarget); else if(act==='delete')deleteItem(contextTarget.item);} hideContextMenu();
         });
        createBtn.addEventListener('click', showCreateMenu);
        createMenu.addEventListener('click', (event) => { /* ... unchanged ... */
            if(event.target.dataset.type) createNewItem(event.target.dataset.type); hideCreateMenu();
         });
        ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eName => { /* ... unchanged deleteBtn listener setup ... */
             deleteBtn.addEventListener(eName, (event) => {
             event.preventDefault();
                 if (eName === 'dragover' || eName === 'dragenter') { clearDropClasses(deleteBtn); deleteBtn.classList.add('drag-over-delete'); insertPosition = 'delete'; currentDragTargetElement = deleteBtn; if(eName === 'dragover') event.dataTransfer.dropEffect = 'move'; }
                 else if (eName === 'dragleave') { deleteBtn.classList.remove('drag-over-delete'); if (!event.relatedTarget || !event.relatedTarget.closest('.file-item')) { insertPosition = null; currentDragTargetElement = null; } }
                 else if (eName === 'drop') { handleDrop(event, null, deleteBtn); }
             });
         });

        function clearSettingDisplay() { /* ... unchanged ... */
            settingContent.innerHTML = `<p>点击左侧设定书查看详情</p>`; Object.assign(settingContent.dataset,{currentItemId:'',currentItemType:'',settingBookId:''}); currentEditingBookTitle=null; isWordCountLimitAlertShown=false; updateRightSidebarTitle('设定详情');
        }
        function updateRightSidebarTitle(title, textContentForCount = null) { 
             const maxChars = 25000; 
             // 新增：确保 title 是字符串，如果为 null/undefined 则视为空字符串
             const currentTitleStr = String(title || ''); 

            if (bookTitleTextSpan && wordCountBadgeSpan) {
                 bookTitleTextSpan.textContent = currentTitleStr || '设定详情'; // 设置标题，如果为空则显示默认

                 // 使用 currentTitleStr 进行判断
                 if (textContentForCount !== null && currentTitleStr !== '设定详情' && !currentTitleStr.startsWith("关联《")) {
                      const charCount = countCharacters(textContentForCount); 
                      wordCountBadgeSpan.textContent = `(${charCount} / ${maxChars} 字)`; 
                      wordCountBadgeSpan.style.display = 'inline-block'; 
                    const isOverLimit = charCount > maxChars;
                      wordCountBadgeSpan.classList.toggle('limit-exceeded', isOverLimit);
                      if (isOverLimit && !isWordCountLimitAlertShown) { 
                           alert(`字数（字符数）已超过 ${maxChars} 字！`); 
                            isWordCountLimitAlertShown = true;
                        }
                      else if (!isOverLimit) isWordCountLimitAlertShown = false;
                    } else {
                     // 不满足条件时隐藏角标
                    wordCountBadgeSpan.style.display = 'none';
                    wordCountBadgeSpan.classList.remove('limit-exceeded');
                    isWordCountLimitAlertShown = false;
                }
             } else if (rightSidebarTitle) { 
                 // Fallback
                 rightSidebarTitle.textContent = currentTitleStr || '设定详情';
             }
         }
        async function updateUserSettingAPI(settingKey, settingValue) { /* ... unchanged ... */
             return await fetchAPI('/api/user/settings', { method: 'PUT', body: { [settingKey]: settingValue } });
         }
        async function getUnassociatedBooksAPI() { /* ... unchanged ... */
            return await fetchAPI('/api/books/unassociated');
        }

        async function openBook(bookData) {
            console.log(`[Open Book] Opening book: ${bookData.name} (ID: ${bookData.id})`);
            showEditorArea(); 
            clearSettingDisplay(); 
            
            if (quill) {
                quill.disable(); // 禁用编辑器防止操作
                // 设置 Delta 为空数组来清空内容，然后插入加载文本
                quill.setContents([], 'silent'); 
                quill.setText('加载中...', 'silent'); 
                console.log("[Open Book] Quill editor cleared and set to 'Loading...'.");
            } else {
                // 如果 Quill 实例不存在，这是个问题
                console.error("[Open Book] Quill instance is not available!");
                // 可以在这里显示错误或尝试重新初始化，但理论上不应发生
                novelContentDiv.textContent = '编辑器初始化失败，请刷新页面。';
                 return; // 无法继续
            }
            
            Object.assign(novelContentDiv.dataset, { currentItemId: bookData.id, currentItemType: 'book' });
            currentEditingBookTitle = bookData.name; 
            isWordCountLimitAlertShown = false; 
            updateRightSidebarTitle(currentEditingBookTitle, '加载中...'); // 显示标题和加载状态

            try {
            const contentData = await getContentAPI(bookData.id);
                console.log("[Open Book] Received content data:", contentData); // 打印获取到的数据

                if (contentData && typeof contentData.content === 'string') { // 检查 content 是否存在且为字符串
                    if(quill) {
                        console.log("[Open Book] Setting Quill content with received HTML.");
                        // 先清空 (以防万一setText没完全清干净或有残留格式)
                        quill.setContents([], 'silent'); 
                        // 插入获取到的 HTML 内容
                        quill.clipboard.dangerouslyPasteHTML(0, contentData.content || '', 'silent'); 
                        quill.history.clear(); 
                        quill.setSelection(0, 0); 
                        console.log("[Open Book] Quill content set successfully.");
                    }
                    hasUnsavedChanges = false; // 重置未保存标记
                    updateRightSidebarTitle(currentEditingBookTitle, quill ? quill.getText() : ''); // 更新字数统计
                    console.log("[Open Book] Sidebar title updated.");

                if (contentData.associatedSetting) {
                        console.log("[Open Book] Loading associated setting...");
                    const fullSettingData = await getContentAPI(contentData.associatedSetting.id);
                    if (fullSettingData) {
                        displaySettingDetails(fullSettingData);
                            Object.assign(settingContent.dataset, {currentItemId: fullSettingData.id, currentItemType: 'setting'});
                            console.log("[Open Book] Associated setting displayed.");
                    } else {
                         console.error('[Open Book] Failed to fetch full details for associated setting.');
                             clearSettingDisplay(); 
                    }
                } else {
                        console.log('[Open Book] No associated setting found.');
                        clearSettingDisplay(); 
                }
            } else {
                    // API 调用成功但数据格式不对或 content 丢失
                    console.error('[Open Book] Failed to get valid content data. Response:', contentData);
                    if(quill) quill.setText('加载内容失败或格式错误。');
                    Object.assign(novelContentDiv.dataset, { currentItemId: '', currentItemType: '' });
                    updateRightSidebarTitle(bookData.name); // 显示标题但无字数
                    currentEditingBookTitle = null; clearSettingDisplay();
                }
            } catch (error) {
                // API 调用本身失败 (网络错误等)
                 console.error('[Open Book] Error fetching content via API:', error);
                 if(quill) quill.setText('加载内容时发生网络错误。');
                 Object.assign(novelContentDiv.dataset, { currentItemId: '', currentItemType: '' });
                 updateRightSidebarTitle(bookData.name); 
                 currentEditingBookTitle = null; clearSettingDisplay();
            } finally {
                // 无论成功失败，重新启用编辑器
                 if (quill) {
                    quill.enable();
                    console.log("[Open Book] Quill editor enabled.");
                 }
            }
            console.log("[Open Book] Finished opening book function.");
        }

        function renderUnassociatedBookList(books, settingBookId, containerElement) { /* ... unchanged ... */
             containerElement.innerHTML=''; const settingItem=fileList.querySelector(`.file-item[data-id="${settingBookId}"]`); const settingName=settingItem?settingItem.querySelector('.item-name').textContent:'此设定书';
             containerElement.innerHTML=`<h4>将《${settingName}》关联到哪本书籍？</h4>`; if(!books||books.length===0){containerElement.innerHTML+='<p style="color:#6c757d;">没有未关联的书籍。</p>'; return;}
             const ul=document.createElement('ul'); ul.className='unassociated-book-list'; ul.dataset.settingBookId=settingBookId;
             books.forEach(book=>{const li=document.createElement('li'); li.className='unassociated-book-item'; li.dataset.bookId=book.id; li.innerHTML=`<i class="fas fa-book"></i> <span>${book.name}</span>`; li.addEventListener('click',(e)=>handleAssociateAndOpenBook(e,settingBookId)); ul.appendChild(li);});
            containerElement.appendChild(ul);
        }
        async function handleAssociateAndOpenBook(event, settingBookId) { /* ... unchanged ... */
            const li=event.currentTarget; const bookId=li.dataset.bookId; const bookName=li.querySelector('span').textContent;
            li.closest('.unassociated-book-list').style.pointerEvents='none'; li.style.backgroundColor='#d1e7dd'; li.innerHTML+=' <i>关联中...</i>';
            const result = await associateSettingAPI(bookId, settingBookId);
            if(result?.id==bookId){ await openBook({id:bookId, name:bookName, type:'book'}); }
            else { alert('关联失败'); li.closest('.unassociated-book-list').style.pointerEvents='auto'; li.style.backgroundColor=''; li.querySelector('i:last-child')?.remove(); }
         }

        function showEditorArea() { /* ... unchanged ... */
            if(centralDisplayArea) centralDisplayArea.style.display='none';
            const editorAreaContainer=document.querySelector('.novel-editor-area'); if(editorAreaContainer) editorAreaContainer.style.display='flex';
            if(promptBar) promptBar.style.display='flex';
        }
        function showCentralDisplay() { /* ... unchanged ... */
             if(centralDisplayArea){centralDisplayArea.innerHTML='<div><i>加载中...</i></div>'; centralDisplayArea.style.display='block';}
             const editorAreaContainer=document.querySelector('.novel-editor-area'); if(editorAreaContainer) editorAreaContainer.style.display='none';
        }

        async function populateTemplateSelector() { /* ... unchanged ... */
             try{const templates=await fetchAPI('/api/prompt-templates'); templateSelect.innerHTML='<option value="">-- 选择模板 --</option>'; if(templates) templates.forEach(t=>{const opt=document.createElement('option');opt.value=t.id;opt.textContent=t.name;if(t.is_default)opt.selected=true;templateSelect.appendChild(opt);});}catch(e){templateSelect.innerHTML='<option value="">加载失败</option>';}
         }
        async function populateAiServiceSelector() { /* ... unchanged ... */
             try{const services=await fetchAPI('/api/ai-services/available'); aiServiceSelect.innerHTML='<option value="">-- 使用默认 --</option>'; if(services) services.forEach(s=>{const opt=document.createElement('option');opt.value=s.id;opt.textContent=s.name;aiServiceSelect.appendChild(opt);});}catch(e){aiServiceSelect.innerHTML='<option value="">加载失败</option>';}
         }

        function debounce(func, wait) { /* ... unchanged ... */
             let timeout; return(...args)=>{clearTimeout(timeout); timeout=setTimeout(()=>func.apply(this,args), wait);};
         }

        const settingContentElement = document.getElementById('setting-content');
        let debounceSaveSettings = null; 

        async function autoSaveSettings() { /* ... unchanged ... */
            const list = settingContentElement.querySelector('.setting-list'); const bookId = list?.dataset.settingBookId; const btn = document.getElementById('save-settings-btn');
            if(list && bookId){const settings=Array.from(list.querySelectorAll('.setting-item')).map(i=>({text:i.querySelector('textarea').value, enabled:i.querySelector('input[type=checkbox]').checked})); if(btn&&!btn.disabled)btn.textContent='自动保存中...'; const result=await updateContentAPI(bookId,'setting',settings); if(btn&&!btn.disabled){btn.textContent=result?'已自动保存 ✓':'自动保存失败!'; setTimeout(()=>{if(!btn.disabled)btn.textContent='保存设定';},result?1500:2000);} if(!isRestoringState) saveEditorState();}
         }
        debounceSaveSettings = debounce(autoSaveSettings, 2000);

        if (settingContentElement) { /* ... unchanged event listeners using debounceSaveSettings ... */
            ['input','change','blur'].forEach(evt=>{settingContentElement.addEventListener(evt,(e)=>{if(e.target.matches('.setting-text-input, .setting-enabled-toggle')){if(debounceSaveSettings) debounceSaveSettings();}}, evt==='blur');});
            settingContentElement.addEventListener('keydown',(e)=>{if(e.target.matches('.setting-text-input')&&e.key==='Enter'&&!e.shiftKey){e.preventDefault();autoSaveSettings();if(!isRestoringState)saveEditorState(); const nextLi=e.target.closest('.setting-item')?.nextElementSibling; const nextTA=nextLi?.querySelector('textarea'); if(nextTA){nextTA.focus();const len=nextTA.value.length; nextTA.setSelectionRange(len,len);}}});
        }

        [templateSelect, aiServiceSelect, wordCountInput, styleInput].forEach(el => { /* ... unchanged ... */
             if(el) el.addEventListener('change', ()=>{if(!isRestoringState)saveEditorState();});
         });

        window.addEventListener('beforeunload', (event) => { /* ... unchanged, calls saveCurrentBookContent ... */
             isRestoringState=false; saveEditorState();
             if(novelContentDiv.dataset.currentItemType==='book' && hasUnsavedChanges){ if(confirm('您有未保存的更改，要保存吗？')){saveCurrentBookContent();}else{event.preventDefault(); event.returnValue=''; return '';}}
         });

        function saveEditorState() { /* Uses novelContentDiv dataset, logic mostly unchanged */
            if (isRestoringState) return; let currentFile=null;
            const itemId=novelContentDiv.dataset.currentItemId; const itemType=novelContentDiv.dataset.currentItemType;
            if(itemId && itemType==='book'){ const el=fileList.querySelector(`.file-item[data-id="${itemId}"]`); currentFile={id:itemId, type:'book', name:el?.querySelector('.item-name').textContent||currentEditingBookTitle||'?'}; }
            else if(centralDisplayArea.style.display!=='none' && centralDisplayArea.querySelector('.unassociated-book-list')){ const settingId=centralDisplayArea.querySelector('.unassociated-book-list').dataset.settingBookId; if(settingId){ const el=fileList.querySelector(`.file-item[data-id="${settingId}"]`); currentFile={id:settingId, type:'setting', name:el?.querySelector('.item-name').textContent||'?', mode:'associating'}; } }
            const state={lastOpenFile:currentFile, promptSettings:{templateId:templateSelect.value,aiServiceId:aiServiceSelect.value,wordCount:wordCountInput.value,style:styleInput.value}};
            try{localStorage.setItem(EDITOR_STATE_KEY, JSON.stringify(state));}catch(e){console.error('Failed to save state:',e);}
        }

        async function loadEditorState() { /* Uses novelContentDiv dataset, adapts for Quill */
            const savedStateString = localStorage.getItem(EDITOR_STATE_KEY);
             if (!quill && !savedStateString) { console.log("Quill not ready, no state."); return; } // Wait for Quill init
             if (!savedStateString && quill) { // Quill ready, no state
                 showEditorArea(); quill.setText(''); Object.assign(novelContentDiv.dataset,{currentItemId:'',currentItemType:''}); clearSettingDisplay(); updateRightSidebarTitle('设定详情'); return;
             }
            
            isRestoringState = true; 
            try {
                const state = JSON.parse(savedStateString);
                if (state.promptSettings) { // Restore prompt settings first
                    templateSelect.value = state.promptSettings.templateId || '';
                    aiServiceSelect.value = state.promptSettings.aiServiceId || '';
                    wordCountInput.value = state.promptSettings.wordCount || '500';
                    styleInput.value = state.promptSettings.style || '';
                }

                if (state.lastOpenFile?.id) { // Restore last open file/view
                    const { id, type, name, mode } = state.lastOpenFile;
                    const itemElement = fileList.querySelector(`.file-item[data-id="${id}"]`);
                    if (itemElement) {
                        const itemData = { id, type, name: itemElement.querySelector('.item-name').textContent };
                        if (type === 'book') await openBook(itemData); // openBook now uses Quill
                        else if (type === 'setting' && mode === 'associating') {
                            showCentralDisplay(); const books = await getUnassociatedBooksAPI(); renderUnassociatedBookList(books, id, centralDisplayArea); clearSettingDisplay(); updateRightSidebarTitle(`关联《${name}》`);
                        } else { // Folder or other case -> show empty editor
                            showEditorArea(); if(quill) quill.setText(''); updateRightSidebarTitle('设定详情');
                        }
                    } else { // Saved item not found in list
                        showEditorArea(); if(quill) quill.setText(''); clearSettingDisplay(); updateRightSidebarTitle('设定详情');
                    }
                } else { // No last open file saved
                    showEditorArea(); if(quill) quill.setText(''); Object.assign(novelContentDiv.dataset,{currentItemId:'',currentItemType:''}); clearSettingDisplay(); updateRightSidebarTitle('设定详情');
                }
            } catch (e) { console.error('Failed to load state:', e); if(quill) quill.setText(''); clearSettingDisplay(); updateRightSidebarTitle('设定详情'); }
            finally { isRestoringState = false; hasUnsavedChanges = false; }
        }

    </script>
</body>
</html> 